---
ms.date: 05/17/2018
keywords: PowerShell, çekirdek
title: PowerShell 6.0 için bozucu değişiklikler
ms.openlocfilehash: 975c978629f81f0f13a235c3d304e5ec03bae6d0
ms.sourcegitcommit: 5990f04b8042ef2d8e571bec6d5b051e64c9921c
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/12/2019
ms.locfileid: "57795700"
---
# <a name="breaking-changes-for-powershell-60"></a><span data-ttu-id="098e6-103">PowerShell 6.0 için bozucu değişiklikler</span><span class="sxs-lookup"><span data-stu-id="098e6-103">Breaking Changes for PowerShell 6.0</span></span>

## <a name="features-no-longer-available-in-powershell-core"></a><span data-ttu-id="098e6-104">PowerShell Core artık kullanılabilir özellikler</span><span class="sxs-lookup"><span data-stu-id="098e6-104">Features no longer available in PowerShell Core</span></span>

### <a name="powershell-workflow"></a><span data-ttu-id="098e6-105">PowerShell iş akışı</span><span class="sxs-lookup"><span data-stu-id="098e6-105">PowerShell Workflow</span></span>

<span data-ttu-id="098e6-106">[PowerShell iş akışı] [ workflow] üst kısmındaki oluşturan bir Windows PowerShell bir özelliktir [Windows Workflow Foundation (WF)] [ workflow-foundation] oluşturulmasını sağlar uzun süreli veya paralel görevler için güçlü runbook.</span><span class="sxs-lookup"><span data-stu-id="098e6-106">[PowerShell Workflow][workflow] is a feature in Windows PowerShell that builds on top of [Windows Workflow Foundation (WF)][workflow-foundation] that enables the creation of robust runbooks for long-running or parallelized tasks.</span></span>

<span data-ttu-id="098e6-107">Windows Workflow Foundation'da .NET Core desteği eksikliği nedeniyle, biz de PowerShell Core PowerShell iş akışı desteklemeye devam etmeyecek.</span><span class="sxs-lookup"><span data-stu-id="098e6-107">Due to the lack of support for Windows Workflow Foundation in .NET Core, we will not continue to support PowerShell Workflow in PowerShell Core.</span></span>

<span data-ttu-id="098e6-108">Gelecekte, PowerShell iş akışı gerek kalmadan PowerShell dilinde yerel paralellik/eşzamanlılık sağlamak istiyoruz.</span><span class="sxs-lookup"><span data-stu-id="098e6-108">In the future, we would like to enable native parallelism/concurrency in the PowerShell language without the need for PowerShell Workflow.</span></span>

[workflow]: https://docs.microsoft.com/powershell/scripting/core-powershell/workflows-guide
[workflow-foundation]: https://docs.microsoft.com/dotnet/framework/windows-workflow-foundation/

### <a name="custom-snap-ins"></a><span data-ttu-id="098e6-109">Özel bileşenler</span><span class="sxs-lookup"><span data-stu-id="098e6-109">Custom snap-ins</span></span>

<span data-ttu-id="098e6-110">[PowerShell ek bileşenleri] [ snapin] PowerShell topluluğunda yaygın olmayan PowerShell modülleri için öncül olan.</span><span class="sxs-lookup"><span data-stu-id="098e6-110">[PowerShell snap-ins][snapin] are a predecessor to PowerShell modules that do not have widespread adoption in the PowerShell community.</span></span>

<span data-ttu-id="098e6-111">Ek bileşenleri ve bunların kullanım yetersizliği topluluk destekleyen karmaşıklığı nedeniyle, artık özel ek bileşenler de PowerShell Core desteklemiyoruz.</span><span class="sxs-lookup"><span data-stu-id="098e6-111">Due to the complexity of supporting snap-ins and their lack of usage in the community, we no longer support custom snap-ins in PowerShell Core.</span></span>

<span data-ttu-id="098e6-112">Günümüzde, bu keser `ActiveDirectory` ve `DnsClient` modülleri Windows ve Windows Server.</span><span class="sxs-lookup"><span data-stu-id="098e6-112">Today, this breaks the `ActiveDirectory` and `DnsClient` modules in Windows and Windows Server.</span></span>

[snapin]: https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_pssnapins

### <a name="wmi-v1-cmdlets"></a><span data-ttu-id="098e6-113">WMI v1 cmdlet'leri</span><span class="sxs-lookup"><span data-stu-id="098e6-113">WMI v1 cmdlets</span></span>

<span data-ttu-id="098e6-114">Modüller VMI tabanlı iki kümesini destekleyen karmaşıklığı nedeniyle, WMI v1 cmdlet'leri PowerShell çekirdek kaldırıldı:</span><span class="sxs-lookup"><span data-stu-id="098e6-114">Due to the complexity of supporting two sets of WMI-based modules, we removed the WMI v1 cmdlets from PowerShell Core:</span></span>

- `Get-WmiObject`
- `Invoke-WmiMethod`
- `Register-WmiEvent`
- `Set-WmiInstance`

<span data-ttu-id="098e6-115">Bunun yerine, öneririz, yeni işlevsellik ve yeniden tasarlanan bir söz dizimi ile aynı işlevselliği sağlayan (WMI v2 olarak da bilinir) CIM cmdlet'leri kullanın:</span><span class="sxs-lookup"><span data-stu-id="098e6-115">Instead, we recommend that you the use the CIM (aka WMI v2) cmdlets which provide the same functionality with new functionality and a redesigned syntax:</span></span>

- `Get-CimAssociatedInstance`
- `Get-CimClass`
- `Get-CimInstance`
- `Get-CimSession`
- `Invoke-CimMethod`
- `New-CimInstance`
- `New-CimSession`
- `New-CimSessionOption`
- `Register-CimIndicationEvent`
- `Remove-CimInstance`
- `Remove-CimSession`
- `Set-CimInstance`

### <a name="microsoftpowershelllocalaccounts"></a><span data-ttu-id="098e6-116">Microsoft.PowerShell.LocalAccounts</span><span class="sxs-lookup"><span data-stu-id="098e6-116">Microsoft.PowerShell.LocalAccounts</span></span>

<span data-ttu-id="098e6-117">Desteklenmeyen API kullanımı nedeniyle `Microsoft.PowerShell.LocalAccounts` PowerShell çekirdek, daha iyi bir çözüm bulunana kadar kaldırıldı.</span><span class="sxs-lookup"><span data-stu-id="098e6-117">Due to the use of unsupported APIs, `Microsoft.PowerShell.LocalAccounts` has been removed from PowerShell Core until a better solution is found.</span></span>

### <a name="-counter-cmdlets"></a><span data-ttu-id="098e6-118">`*-Counter` cmdlet'leri</span><span class="sxs-lookup"><span data-stu-id="098e6-118">`*-Counter` cmdlets</span></span>

<span data-ttu-id="098e6-119">Desteklenmeyen API kullanımı nedeniyle `*-Counter` PowerShell çekirdek, daha iyi bir çözüm bulunana kadar kaldırıldı.</span><span class="sxs-lookup"><span data-stu-id="098e6-119">Due to the use of unsupported APIs, the `*-Counter` has been removed from PowerShell Core until a better solution is found.</span></span>

### <a name="-eventlog-cmdlets"></a><span data-ttu-id="098e6-120">`*-EventLog` cmdlet'leri</span><span class="sxs-lookup"><span data-stu-id="098e6-120">`*-EventLog` cmdlets</span></span>

<span data-ttu-id="098e6-121">Desteklenmeyen API kullanımı nedeniyle `*-EventLog` PowerShell çekirdek kaldırıldı.</span><span class="sxs-lookup"><span data-stu-id="098e6-121">Due to the use of unsupported APIs, the `*-EventLog` has been removed from PowerShell Core.</span></span> <span data-ttu-id="098e6-122">daha iyi bir çözüm bulunana kadar.</span><span class="sxs-lookup"><span data-stu-id="098e6-122">until a better solution is found.</span></span> <span data-ttu-id="098e6-123">`Get-WinEvent` ve `Create-WinEvent` almak ve Windows üzerinde olayları oluşturmak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="098e6-123">`Get-WinEvent` and `Create-WinEvent` are available to get and create events on Windows.</span></span>

## <a name="enginelanguage-changes"></a><span data-ttu-id="098e6-124">Altyapısı/dil değişiklikleri</span><span class="sxs-lookup"><span data-stu-id="098e6-124">Engine/language changes</span></span>

### <a name="rename-powershellexe-to-pwshexe-5101httpsgithubcompowershellpowershellissues5101"></a><span data-ttu-id="098e6-125">Yeniden adlandırma `powershell.exe` için `pwsh.exe` [#5101](https://github.com/PowerShell/PowerShell/issues/5101)</span><span class="sxs-lookup"><span data-stu-id="098e6-125">Rename `powershell.exe` to `pwsh.exe` [#5101](https://github.com/PowerShell/PowerShell/issues/5101)</span></span>

<span data-ttu-id="098e6-126">Kullanıcılar (aksine, Windows PowerShell) Windows PowerShell Core çağırmak için belirlenimci bir şekilde tanımak için PowerShell Core ikili değiştirilmiştir `pwsh.exe` Windows üzerinde ve `pwsh` Windows dışı platformlarda.</span><span class="sxs-lookup"><span data-stu-id="098e6-126">In order to give users a deterministic way to call PowerShell Core on Windows (as opposed to Windows PowerShell), the PowerShell Core binary was changed to `pwsh.exe` on Windows and `pwsh` on non-Windows platforms.</span></span>

<span data-ttu-id="098e6-127">Kısaltılmış adı, Windows dışı platformlarda Kabukları adlandırma ile tutarlıdır.</span><span class="sxs-lookup"><span data-stu-id="098e6-127">The shortened name is also consistent with naming of shells on non-Windows platforms.</span></span>

### <a name="dont-insert-line-breaks-to-output-except-for-tables-5193httpsgithubcompowershellpowershellissues5193"></a><span data-ttu-id="098e6-128">(Tablolar hariç) çıktısını almak için satır sonları eklemeyin [#5193](https://github.com/PowerShell/PowerShell/issues/5193)</span><span class="sxs-lookup"><span data-stu-id="098e6-128">Don't insert line breaks to output (except for tables) [#5193](https://github.com/PowerShell/PowerShell/issues/5193)</span></span>

<span data-ttu-id="098e6-129">Daha önce çıkış konsolunun genişliğine hizalı ve çıkış terminal boyutlandırılmış beklendiği gibi yeniden biçimlendirildi istemediğiniz anlamına gelir konsolun son genişlikte satır sonları eklenmiştir.</span><span class="sxs-lookup"><span data-stu-id="098e6-129">Previously, output was aligned to the width of the console and line breaks were added at the end width of the console, meaning the output didn't get reformatted as expected if the terminal was resized.</span></span> <span data-ttu-id="098e6-130">Satır sonları hizalı sütunları tutmak gerekli olduğundan tablo, bu değişiklik uygulanmadı.</span><span class="sxs-lookup"><span data-stu-id="098e6-130">This change was not applied to tables, as the line breaks are necessary to keep the columns aligned.</span></span>

### <a name="skip-null-element-check-for-collections-with-a-value-type-element-type-5432httpsgithubcompowershellpowershellissues5432"></a><span data-ttu-id="098e6-131">Atla null öğe onay için bir değer türünün öğe türü olan koleksiyonları [#5432](https://github.com/PowerShell/PowerShell/issues/5432)</span><span class="sxs-lookup"><span data-stu-id="098e6-131">Skip null-element check for collections with a value-type element type [#5432](https://github.com/PowerShell/PowerShell/issues/5432)</span></span>

<span data-ttu-id="098e6-132">İçin `Mandatory` parametresi ve `ValidateNotNull` ve `ValidateNotNullOrEmpty` öznitelikleri, koleksiyonun öğe türü, değer türü ise null öğe onay atlayın.</span><span class="sxs-lookup"><span data-stu-id="098e6-132">For the `Mandatory` parameter and `ValidateNotNull` and `ValidateNotNullOrEmpty` attributes, skip the null-element check if the collection's element type is value type.</span></span>

### <a name="change-outputencoding-to-use-utf-8-nobom-encoding-rather-than-ascii-5369httpsgithubcompowershellpowershellissues5369"></a><span data-ttu-id="098e6-133">Değişiklik `$OutputEncoding` kullanılacak `UTF-8 NoBOM` yerine ASCII kodlaması [#5369](https://github.com/PowerShell/PowerShell/issues/5369)</span><span class="sxs-lookup"><span data-stu-id="098e6-133">Change `$OutputEncoding` to use `UTF-8 NoBOM` encoding rather than ASCII [#5369](https://github.com/PowerShell/PowerShell/issues/5369)</span></span>

<span data-ttu-id="098e6-134">Önceki, ASCII (7-bit), kodlama çıkış bazı durumlarda yanlış değişikliğinin neden olur.</span><span class="sxs-lookup"><span data-stu-id="098e6-134">The previous encoding, ASCII (7-bit), would result in incorrect alteration of the output in some cases.</span></span> <span data-ttu-id="098e6-135">Bu değişiklik yapmaktır `UTF-8 NoBOM` varsayılan, araçları ve işletim sistemleri tarafından desteklenen kodlama ile Unicode çıkış korur.</span><span class="sxs-lookup"><span data-stu-id="098e6-135">This change is to make `UTF-8 NoBOM` default, which preserves Unicode output with an encoding supported by most tools and operating systems.</span></span>

### <a name="remove-allscope-from-most-default-aliases-5268httpsgithubcompowershellpowershellissues5268"></a><span data-ttu-id="098e6-136">Kaldırma `AllScope` çoğu varsayılan eş ad alanından [#5268](https://github.com/PowerShell/PowerShell/issues/5268)</span><span class="sxs-lookup"><span data-stu-id="098e6-136">Remove `AllScope` from most default aliases [#5268](https://github.com/PowerShell/PowerShell/issues/5268)</span></span>

<span data-ttu-id="098e6-137">Kapsam, oluşumunu hızlandırma için `AllScope` birçok varsayılan diğer ad kaldırıldı.</span><span class="sxs-lookup"><span data-stu-id="098e6-137">To speed up scope creation, `AllScope` was removed from most default aliases.</span></span> <span data-ttu-id="098e6-138">`AllScope` arama daha hızlı olduğu için sık kullanılan bazı diğer adlar bırakıldı.</span><span class="sxs-lookup"><span data-stu-id="098e6-138">`AllScope` was left for a few frequently used aliases where the lookup was faster.</span></span>

### <a name="-verbose-and--debug-no-longer-overrides-erroractionpreference-5113httpsgithubcompowershellpowershellissues5113"></a><span data-ttu-id="098e6-139">`-Verbose` ve `-Debug` artık geçersiz kılmalar `$ErrorActionPreference` [#5113](https://github.com/PowerShell/PowerShell/issues/5113)</span><span class="sxs-lookup"><span data-stu-id="098e6-139">`-Verbose` and `-Debug` no longer overrides `$ErrorActionPreference` [#5113](https://github.com/PowerShell/PowerShell/issues/5113)</span></span>

<span data-ttu-id="098e6-140">Daha önce varsa `-Verbose` veya `-Debug` belirtilmiş davranışını geçersiz kılınmış `$ErrorActionPreference`.</span><span class="sxs-lookup"><span data-stu-id="098e6-140">Previously, if `-Verbose` or `-Debug` were specified, it overrode the behavior of `$ErrorActionPreference`.</span></span> <span data-ttu-id="098e6-141">Bu değişikliğe `-Verbose` ve `-Debug` artık davranışını etkileyen `$ErrorActionPreference`.</span><span class="sxs-lookup"><span data-stu-id="098e6-141">With this change, `-Verbose` and `-Debug` no longer affect the behavior of `$ErrorActionPreference`.</span></span>

## <a name="cmdlet-changes"></a><span data-ttu-id="098e6-142">Cmdlet değişiklikleri</span><span class="sxs-lookup"><span data-stu-id="098e6-142">Cmdlet changes</span></span>

### <a name="invoke-restmethod-doesnt-return-useful-info-when-no-data-is-returned-5320httpsgithubcompowershellpowershellissues5320"></a><span data-ttu-id="098e6-143">Hiçbir veri döndürülmez olduğunda çağırma RestMethod yararlı bilgiler döndürmek zorunda değildir.</span><span class="sxs-lookup"><span data-stu-id="098e6-143">Invoke-RestMethod doesn't return useful info when no data is returned.</span></span> [<span data-ttu-id="098e6-144">#5320</span><span class="sxs-lookup"><span data-stu-id="098e6-144">#5320</span></span>](https://github.com/PowerShell/PowerShell/issues/5320)

<span data-ttu-id="098e6-145">Bir API döndürdüğünde yalnızca `null`, Invoke-RestMethod serileştirme Bu dize olarak `"null"` yerine `$null`.</span><span class="sxs-lookup"><span data-stu-id="098e6-145">When an API returns just `null`, Invoke-RestMethod was serializing this as the string `"null"` instead of `$null`.</span></span> <span data-ttu-id="098e6-146">Bu değişiklik mantığında düzeltmeleri `Invoke-RestMethod` düzgün geçerli tek değer JSON seri hale getirmek için `null` değişmez değer olarak `$null`.</span><span class="sxs-lookup"><span data-stu-id="098e6-146">This change fixes the logic in `Invoke-RestMethod` to properly serialize a valid single value JSON `null` literal as `$null`.</span></span>

### <a name="remove--computername-from--computer-cmdlets-5277httpsgithubcompowershellpowershellissues5277"></a><span data-ttu-id="098e6-147">Kaldırma `-ComputerName` gelen `*-Computer` cmdlet'leri [#5277](https://github.com/PowerShell/PowerShell/issues/5277)</span><span class="sxs-lookup"><span data-stu-id="098e6-147">Remove `-ComputerName` from `*-Computer` cmdlets [#5277](https://github.com/PowerShell/PowerShell/issues/5277)</span></span>

<span data-ttu-id="098e6-148">RPC remoting Corefx'te (özellikle de Windows olmayan platformlar için) ve bir PowerShell tutarlı remoting deneyimi sağlama ile ilgili sorunlar nedeniyle `-ComputerName` parametresi üzerinden kaldırıldı `\*-Computer` cmdlet'leri.</span><span class="sxs-lookup"><span data-stu-id="098e6-148">Due to issues with RPC remoting in CoreFX (particularly on non-Windows platforms) and ensuring a consistent remoting experience in PowerShell, the `-ComputerName` parameter was removed from the `\*-Computer` cmdlets.</span></span> <span data-ttu-id="098e6-149">Kullanım `Invoke-Command` cmdlet'leri uzaktan yürütülecek şekilde yerine.</span><span class="sxs-lookup"><span data-stu-id="098e6-149">Use `Invoke-Command` instead as the way to execute cmdlets remotely.</span></span>

### <a name="remove--computername-from--service-cmdlets-5090httpsgithubcompowershellpowershellissues5094"></a><span data-ttu-id="098e6-150">Kaldırma `-ComputerName` gelen `*-Service` cmdlet'leri [#5090](https://github.com/PowerShell/PowerShell/issues/5094)</span><span class="sxs-lookup"><span data-stu-id="098e6-150">Remove `-ComputerName` from `*-Service` cmdlets [#5090](https://github.com/PowerShell/PowerShell/issues/5094)</span></span>

<span data-ttu-id="098e6-151">PSRP, tutarlı kullanımını teşvik etmek için `-ComputerName` parametresi üzerinden kaldırıldı `*-Service` cmdlet'leri.</span><span class="sxs-lookup"><span data-stu-id="098e6-151">In order to encourage the consistent use of PSRP, the `-ComputerName` parameter was removed from `*-Service` cmdlets.</span></span>

### <a name="fix-get-item--literalpath-ab-if-ab-doesnt-actually-exist-to-return-error-5197httpsgithubcompowershellpowershellissues5197"></a><span data-ttu-id="098e6-152">Düzeltme `Get-Item -LiteralPath a*b` varsa `a*b` gerçekten hata döndüreceğini yok [#5197](https://github.com/PowerShell/PowerShell/issues/5197)</span><span class="sxs-lookup"><span data-stu-id="098e6-152">Fix `Get-Item -LiteralPath a*b` if `a*b` doesn't actually exist to return error [#5197](https://github.com/PowerShell/PowerShell/issues/5197)</span></span>

<span data-ttu-id="098e6-153">Daha önce `-LiteralPath` söz konusu bir joker karakter, disklerle aynı şekilde işlem `-Path` ve joker karakter hiçbir dosya bulunamazsa, sessizce çıkmak.</span><span class="sxs-lookup"><span data-stu-id="098e6-153">Previously, `-LiteralPath` given a wildcard would treat it the same as `-Path` and if the wildcard found no files, it would silently exit.</span></span> <span data-ttu-id="098e6-154">Doğru davranışı, olmalıdır `-LiteralPath` dosya yoksa hata gerektiği şekilde sabitidir.</span><span class="sxs-lookup"><span data-stu-id="098e6-154">Correct behavior should be that `-LiteralPath` is literal so if the file doesn't exist, it should error.</span></span> <span data-ttu-id="098e6-155">Değişikliktir ile kullanılan joker karakterler değerlendirilecek `-Literal` sabit değer olarak.</span><span class="sxs-lookup"><span data-stu-id="098e6-155">Change is to treat wildcards used with `-Literal` as literal.</span></span>

### <a name="import-csv-should-apply-pstypenames-upon-import-when-type-information-is-present-in-the-csv-5134httpsgithubcompowershellpowershellissues5134"></a><span data-ttu-id="098e6-156">`Import-Csv` uygulamalıdır `PSTypeNames` CSV'ye tür bilgisi varsa içeri aktarma sırasında [#5134](https://github.com/PowerShell/PowerShell/issues/5134)</span><span class="sxs-lookup"><span data-stu-id="098e6-156">`Import-Csv` should apply `PSTypeNames` upon import when type information is present in the CSV [#5134](https://github.com/PowerShell/PowerShell/issues/5134)</span></span>

<span data-ttu-id="098e6-157">Nesne daha önce dışarı kullanarak `Export-CSV` ile `TypeInformation` içeri `ConvertFrom-Csv` tür bilgilerini koruyarak değil.</span><span class="sxs-lookup"><span data-stu-id="098e6-157">Previously, objects exported using `Export-CSV` with `TypeInformation` imported with `ConvertFrom-Csv` were not retaining the type information.</span></span> <span data-ttu-id="098e6-158">Bu değişiklik türü bilgileri ekler `PSTypeNames` üyesi kullanılabilir durumdaysa CSV dosyasındaki.</span><span class="sxs-lookup"><span data-stu-id="098e6-158">This change adds the type information to `PSTypeNames` member if available from the CSV file.</span></span>

### <a name="-notypeinformation-should-be-default-on-export-csv-5131httpsgithubcompowershellpowershellissues5131"></a><span data-ttu-id="098e6-159">`-NoTypeInformation` Varsayılan değer olmalıdır `Export-Csv` [#5131](https://github.com/PowerShell/PowerShell/issues/5131)</span><span class="sxs-lookup"><span data-stu-id="098e6-159">`-NoTypeInformation` should be default on `Export-Csv` [#5131](https://github.com/PowerShell/PowerShell/issues/5131)</span></span>

<span data-ttu-id="098e6-160">Bu değişiklik adresi Müşteri geri bildirimi varsayılan davranışını bulunuldu `Export-CSV` tür bilgileri içerecek şekilde.</span><span class="sxs-lookup"><span data-stu-id="098e6-160">This change was made to address customer feedback on the default behavior of `Export-CSV` to include type information.</span></span>

<span data-ttu-id="098e6-161">Daha önce cmdlet'i bir yorum nesnenin türü adını içeren ilk satırı çıktı.</span><span class="sxs-lookup"><span data-stu-id="098e6-161">Previously, the cmdlet would output a comment as the first line containing the type name of the object.</span></span> <span data-ttu-id="098e6-162">Çoğu araçları tarafından anlaşılmayan gibi varsayılan olarak bu bastırmak için farklıdır.</span><span class="sxs-lookup"><span data-stu-id="098e6-162">The change is to suppress this by default as it's not understood by most tools.</span></span> <span data-ttu-id="098e6-163">Kullanım `-IncludeTypeInformation` önceki davranışı korumak için.</span><span class="sxs-lookup"><span data-stu-id="098e6-163">Use `-IncludeTypeInformation` to retain the previous behavior.</span></span>

### <a name="web-cmdlets-should-warn-when--credential-is-sent-over-unencrypted-connections-5112httpsgithubcompowershellpowershellissues5112"></a><span data-ttu-id="098e6-164">Web cmdlet'leri uyar `-Credential` şifrelenmemiş bir bağlantı üzerinden gönderilir [#5112](https://github.com/PowerShell/PowerShell/issues/5112)</span><span class="sxs-lookup"><span data-stu-id="098e6-164">Web Cmdlets should warn when `-Credential` is sent over unencrypted connections [#5112](https://github.com/PowerShell/PowerShell/issues/5112)</span></span>

<span data-ttu-id="098e6-165">HTTP kullanarak parolaları da dahil olmak üzere içerik düz metin gönderilir.</span><span class="sxs-lookup"><span data-stu-id="098e6-165">When using HTTP, content including passwords are sent as clear-text.</span></span> <span data-ttu-id="098e6-166">Bu değişiklik, değil Bu varsayılan olarak izin verir ve kimlik bilgilerini güvenli bir şekilde geçirilirse, bir hata döndürebilir oluşturmaktır.</span><span class="sxs-lookup"><span data-stu-id="098e6-166">This change is to not allow this by default and return an error if credentials are being passed in an insecure manner.</span></span> <span data-ttu-id="098e6-167">Kullanıcılar bu kullanarak konusunda atlayabilir `-AllowUnencryptedAuthentication` geçin.</span><span class="sxs-lookup"><span data-stu-id="098e6-167">Users can bypass this by using the `-AllowUnencryptedAuthentication` switch.</span></span>

## <a name="api-changes"></a><span data-ttu-id="098e6-168">API değişiklikleri</span><span class="sxs-lookup"><span data-stu-id="098e6-168">API changes</span></span>

### <a name="remove-addtypecommandbase-class-5407httpsgithubcompowershellpowershellissues5407"></a><span data-ttu-id="098e6-169">Kaldırma `AddTypeCommandBase` sınıfı [#5407](https://github.com/PowerShell/PowerShell/issues/5407)</span><span class="sxs-lookup"><span data-stu-id="098e6-169">Remove `AddTypeCommandBase` class [#5407](https://github.com/PowerShell/PowerShell/issues/5407)</span></span>

<span data-ttu-id="098e6-170">`AddTypeCommandBase` Sınıfı üzerinden kaldırıldı `Add-Type` performansını artırmak için.</span><span class="sxs-lookup"><span data-stu-id="098e6-170">The `AddTypeCommandBase` class was removed from `Add-Type` to improve performance.</span></span> <span data-ttu-id="098e6-171">Bu sınıf, yalnızca Add-Type cmdlet'i tarafından kullanılır ve kullanıcıların etkilememesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="098e6-171">This class is only used by the Add-Type cmdlet and should not impact users.</span></span>

### <a name="unify-cmdlets-with-parameter--encoding-to-be-of-type-systemtextencoding-5080httpsgithubcompowershellpowershellissues5080"></a><span data-ttu-id="098e6-172">Cmdlet parametresi ile birleştirin `-Encoding` türünde olmasını `System.Text.Encoding` [#5080](https://github.com/PowerShell/PowerShell/issues/5080)</span><span class="sxs-lookup"><span data-stu-id="098e6-172">Unify cmdlets with parameter `-Encoding` to be of type `System.Text.Encoding` [#5080](https://github.com/PowerShell/PowerShell/issues/5080)</span></span>

<span data-ttu-id="098e6-173">`-Encoding` Değer `Byte` dosya sistemi sağlayıcısı cmdlet'leri kaldırıldı.</span><span class="sxs-lookup"><span data-stu-id="098e6-173">The `-Encoding` value `Byte` has been removed from the filesystem provider cmdlets.</span></span> <span data-ttu-id="098e6-174">Yeni bir parametre `-AsByteStream`, bayt akışı olarak gerekli olduğunu belirtmek için artık kullanılan giriş veya çıkış bayt akışı alınır.</span><span class="sxs-lookup"><span data-stu-id="098e6-174">A new parameter, `-AsByteStream`, is now used to specify that a byte stream is required as input or that the output is a stream of bytes.</span></span>

### <a name="add-better-error-message-for-empty-and-null--uformat-parameter-5055httpsgithubcompowershellpowershellissues5055"></a><span data-ttu-id="098e6-175">Daha iyi hata iletisi boş ve null ekleme `-UFormat` parametre [#5055](https://github.com/PowerShell/PowerShell/issues/5055)</span><span class="sxs-lookup"><span data-stu-id="098e6-175">Add better error message for empty and null `-UFormat` parameter [#5055](https://github.com/PowerShell/PowerShell/issues/5055)</span></span>

<span data-ttu-id="098e6-176">Daha önce ne zaman geçirme boş bir biçim dizesi için `-UFormat`, faydasız bir ileti görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="098e6-176">Previously, when passing an empty format string to `-UFormat`, an unhelpful error message would appear.</span></span> <span data-ttu-id="098e6-177">Daha açıklayıcı hata eklendi.</span><span class="sxs-lookup"><span data-stu-id="098e6-177">A more descriptive error has been added.</span></span>

### <a name="clean-up-console-code-4995httpsgithubcompowershellpowershellissues4995"></a><span data-ttu-id="098e6-178">Konsol kod Temizleme [#4995](https://github.com/PowerShell/PowerShell/issues/4995)</span><span class="sxs-lookup"><span data-stu-id="098e6-178">Clean up console code [#4995](https://github.com/PowerShell/PowerShell/issues/4995)</span></span>

<span data-ttu-id="098e6-179">PowerShell Core içinde desteklenmez ve Windows PowerShell için eski nedenlerle oldukları gibi desteği eklemek için bir plan yok olarak aşağıdaki özellikler kaldırıldı: `-psconsolefile` anahtar ve kodu `-importsystemmodules` geçiş kodu ve kod değiştirme yazı tipi.</span><span class="sxs-lookup"><span data-stu-id="098e6-179">The following features were removed as they are not supported in PowerShell Core, and there are no plans to add support as they exist for legacy reasons for Windows PowerShell: `-psconsolefile` switch and code, `-importsystemmodules` switch and code, and font changing code.</span></span>

### <a name="removed-runspaceconfiguration-support-4942httpsgithubcompowershellpowershellissues4942"></a><span data-ttu-id="098e6-180">Kaldırılan `RunspaceConfiguration` Destek [#4942](https://github.com/PowerShell/PowerShell/issues/4942)</span><span class="sxs-lookup"><span data-stu-id="098e6-180">Removed `RunspaceConfiguration` support [#4942](https://github.com/PowerShell/PowerShell/issues/4942)</span></span>

<span data-ttu-id="098e6-181">Daha önce bir PowerShell çalışma program aracılığıyla oluştururken API'sini kullanarak eski kullanabileceğinizi [ `RunspaceConfiguration` ] [ runspaceconfig] veya yeni [ `InitialSessionState` ] [ iss].</span><span class="sxs-lookup"><span data-stu-id="098e6-181">Previously, when creating a PowerShell runspace programmatically using the API you could use the legacy [`RunspaceConfiguration`][runspaceconfig] or the newer [`InitialSessionState`][iss].</span></span> <span data-ttu-id="098e6-182">Bu değişiklik desteği kaldırıldı `RunspaceConfiguration` ve yalnızca destekler `InitialSessionState`.</span><span class="sxs-lookup"><span data-stu-id="098e6-182">This change removed support for `RunspaceConfiguration` and only supports `InitialSessionState`.</span></span>

[runspaceconfig]: https://docs.microsoft.com/dotnet/api/system.management.automation.runspaces.runspaceconfiguration
[iss]: https://docs.microsoft.com/dotnet/api/system.management.automation.runspaces.initialsessionstate

### <a name="commandinvocationintrinsicsinvokescript-bind-arguments-to-input-instead-of-args-4923httpsgithubcompowershellpowershellissues4923"></a><span data-ttu-id="098e6-183">`CommandInvocationIntrinsics.InvokeScript` bağımsız değişken bağlama `$input` yerine `$args` [#4923](https://github.com/PowerShell/PowerShell/issues/4923)</span><span class="sxs-lookup"><span data-stu-id="098e6-183">`CommandInvocationIntrinsics.InvokeScript` bind arguments to `$input` instead of `$args` [#4923](https://github.com/PowerShell/PowerShell/issues/4923)</span></span>

<span data-ttu-id="098e6-184">Bağımsız olarak yerine Giriş bağımsız değişken olarak geçirilen bağımsız değişkenler olarak hatalı bir parametre konumunu sonuçlandı.</span><span class="sxs-lookup"><span data-stu-id="098e6-184">An incorrect position of a parameter resulted in the args passed as input instead of as args.</span></span>

### <a name="remove-unsupported--showwindow-switch-from-get-help-4903httpsgithubcompowershellpowershellissues4903"></a><span data-ttu-id="098e6-185">Desteklenmeyen Kaldır `-showwindow` geçmek `Get-Help` [#4903](https://github.com/PowerShell/PowerShell/issues/4903)</span><span class="sxs-lookup"><span data-stu-id="098e6-185">Remove unsupported `-showwindow` switch from `Get-Help` [#4903](https://github.com/PowerShell/PowerShell/issues/4903)</span></span>

<span data-ttu-id="098e6-186">`-showwindow` Coreclr'de desteklenmeyen WPF kullanır.</span><span class="sxs-lookup"><span data-stu-id="098e6-186">`-showwindow` relies on WPF, which is not supported on CoreCLR.</span></span>

### <a name="allow--to-be-used-in-registry-path-for-remove-item-4866httpsgithubcompowershellpowershellissues4866"></a><span data-ttu-id="098e6-187">İzin ver \* için kayıt defteri yolunda kullanılacak `Remove-Item` [#4866](https://github.com/PowerShell/PowerShell/issues/4866)</span><span class="sxs-lookup"><span data-stu-id="098e6-187">Allow \* to be used in registry path for `Remove-Item` [#4866](https://github.com/PowerShell/PowerShell/issues/4866)</span></span>

<span data-ttu-id="098e6-188">Daha önce `-LiteralPath` söz konusu bir joker karakter, disklerle aynı şekilde işlem `-Path` ve joker karakter hiçbir dosya bulunamazsa, sessizce çıkmak.</span><span class="sxs-lookup"><span data-stu-id="098e6-188">Previously, `-LiteralPath` given a wildcard would treat it the same as `-Path` and if the wildcard found no files, it would silently exit.</span></span> <span data-ttu-id="098e6-189">Doğru davranışı, olmalıdır `-LiteralPath` dosya yoksa hata gerektiği şekilde sabitidir.</span><span class="sxs-lookup"><span data-stu-id="098e6-189">Correct behavior should be that `-LiteralPath` is literal so if the file doesn't exist, it should error.</span></span> <span data-ttu-id="098e6-190">Değişikliktir ile kullanılan joker karakterler değerlendirilecek `-Literal` sabit değer olarak.</span><span class="sxs-lookup"><span data-stu-id="098e6-190">Change is to treat wildcards used with `-Literal` as literal.</span></span>

### <a name="fix-set-service-failing-test-4802httpsgithubcompowershellpowershellissues4802"></a><span data-ttu-id="098e6-191">Düzeltme `Set-Service` sınama başarısız [#4802](https://github.com/PowerShell/PowerShell/issues/4802)</span><span class="sxs-lookup"><span data-stu-id="098e6-191">Fix `Set-Service` failing test [#4802](https://github.com/PowerShell/PowerShell/issues/4802)</span></span>

<span data-ttu-id="098e6-192">Daha önce varsa `New-Service -StartupType foo` kullanılan `foo` yok sayıldı ve bazı varsayılan başlatma türüyle hizmet oluşturuldu.</span><span class="sxs-lookup"><span data-stu-id="098e6-192">Previously, if `New-Service -StartupType foo` was used, `foo` was ignored and the service was created with some default startup type.</span></span> <span data-ttu-id="098e6-193">Bu değişiklik, açıkça geçersiz başlangıç türü için bir hata durum oluşturmaktır.</span><span class="sxs-lookup"><span data-stu-id="098e6-193">This change is to explicitly throw an error for an invalid startup type.</span></span>

### <a name="rename-isosx-to-ismacos-4700httpsgithubcompowershellpowershellissues4700"></a><span data-ttu-id="098e6-194">Yeniden adlandırma `$IsOSX` için `$IsMacOS` [#4700](https://github.com/PowerShell/PowerShell/issues/4700)</span><span class="sxs-lookup"><span data-stu-id="098e6-194">Rename `$IsOSX` to `$IsMacOS` [#4700](https://github.com/PowerShell/PowerShell/issues/4700)</span></span>

<span data-ttu-id="098e6-195">PowerShell'de adlandırma bizim adlandırma ile tutarlı ve macOS OSX yerine Apple'nın kullanımı için uygun olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="098e6-195">The naming in PowerShell should be consistent with our naming and conform to Apple's use of macOS instead of OSX.</span></span> <span data-ttu-id="098e6-196">Ancak, okunabilirlik için ve tutarlı bir şekilde biz ile Pascal kaldığını büyük/küçük harf.</span><span class="sxs-lookup"><span data-stu-id="098e6-196">However, for readability and consistently we are staying with Pascal casing.</span></span>

### <a name="make-error-message-consistent-when-invalid-script-is-passed-to--file-better-error-when-passed-ambiguous-argument-4573httpsgithubcompowershellpowershellissues4573"></a><span data-ttu-id="098e6-197">Geçersiz betik geçirildiğinde hata iletisi tutarlı hale getirmek için - dosya, daha iyi belirsiz bağımsız değişken geçirildi hatası [#4573](https://github.com/PowerShell/PowerShell/issues/4573)</span><span class="sxs-lookup"><span data-stu-id="098e6-197">Make error message consistent when invalid script is passed to -File, better error when passed ambiguous argument [#4573](https://github.com/PowerShell/PowerShell/issues/4573)</span></span>

<span data-ttu-id="098e6-198">Çıkış kodlarını değiştirmek `pwsh.exe` UNIX kuralları ile hizalamak için</span><span class="sxs-lookup"><span data-stu-id="098e6-198">Change the exit codes of `pwsh.exe` to align with Unix conventions</span></span>

### <a name="removal-of-localaccount-and-cmdlets-from--diagnostics-modules-4302httpsgithubcompowershellpowershellissues4302-4303httpsgithubcompowershellpowershellissues4303"></a><span data-ttu-id="098e6-199">Kaldırılmasını `LocalAccount` ve cmdlet'lerinden `Diagnostics` modüller.</span><span class="sxs-lookup"><span data-stu-id="098e6-199">Removal of `LocalAccount` and cmdlets from  `Diagnostics` modules.</span></span> <span data-ttu-id="098e6-200">[#4302](https://github.com/PowerShell/PowerShell/issues/4302) [#4303](https://github.com/PowerShell/PowerShell/issues/4303)</span><span class="sxs-lookup"><span data-stu-id="098e6-200">[#4302](https://github.com/PowerShell/PowerShell/issues/4302) [#4303](https://github.com/PowerShell/PowerShell/issues/4303)</span></span>

<span data-ttu-id="098e6-201">Desteklenmeyen API nedeniyle `LocalAccounts` modülü ve `Counter` cmdlet'leri `Diagnostics` daha iyi bir çözüm bulunana kadar modülü kaldırıldı.</span><span class="sxs-lookup"><span data-stu-id="098e6-201">Due to unsupported APIs, the `LocalAccounts` module and the `Counter` cmdlets in the `Diagnostics` module were removed until a better solution is found.</span></span>

### <a name="executing-powershell-script-with-bool-parameter-does-not-work-4036httpsgithubcompowershellpowershellissues4036"></a><span data-ttu-id="098e6-202">Bool parametresiyle birlikte PowerShell Betiği Yürütülüyor çalışmıyor [#4036](https://github.com/PowerShell/PowerShell/issues/4036)</span><span class="sxs-lookup"><span data-stu-id="098e6-202">Executing PowerShell script with bool parameter does not work [#4036](https://github.com/PowerShell/PowerShell/issues/4036)</span></span>

<span data-ttu-id="098e6-203">Daha önce kullanarak **powershell.exe** (artık **pwsh.exe**) kullanarak bir PowerShell Betiği yürütmek için `-File` başarılı şekilde sağlanan `$true` / `$false` parametre olarak değerler.</span><span class="sxs-lookup"><span data-stu-id="098e6-203">Previously, using **powershell.exe** (now **pwsh.exe**) to execute a PowerShell script using `-File` provided no way to pass `$true`/`$false` as parameter values.</span></span> <span data-ttu-id="098e6-204">Destek `$true` / `$false` ayrıştırılmış değerler için parametre olarak eklendi.</span><span class="sxs-lookup"><span data-stu-id="098e6-204">Support for `$true`/`$false` as parsed values to parameters was added.</span></span> <span data-ttu-id="098e6-205">Şu anda belgelenmiş söz dizimi işe yaramazsa gibi anahtar değerlerini de desteklenir.</span><span class="sxs-lookup"><span data-stu-id="098e6-205">Switch values are also supported as currently documented syntax doesn't work.</span></span>

### <a name="remove-clrversion-property-from-psversiontable-4027httpsgithubcompowershellpowershellissues4027"></a><span data-ttu-id="098e6-206">Kaldırma `ClrVersion` özelliğinden `$PSVersionTable` [#4027](https://github.com/PowerShell/PowerShell/issues/4027)</span><span class="sxs-lookup"><span data-stu-id="098e6-206">Remove `ClrVersion` property from `$PSVersionTable` [#4027](https://github.com/PowerShell/PowerShell/issues/4027)</span></span>

<span data-ttu-id="098e6-207">`ClrVersion` Özelliği `$PSVersionTable` olduğu CoreCLR ile kullanışlı değil, son kullanıcılar bu değeri uyumluluğunu belirlemek için kullanılmaması gereken.</span><span class="sxs-lookup"><span data-stu-id="098e6-207">The `ClrVersion` property of `$PSVersionTable` is not useful with CoreCLR, end users should not be using that value to determine compatibility.</span></span>

### <a name="change-positional-parameter-for-powershellexe-from--command-to--file-4019httpsgithubcompowershellpowershellissues4019"></a><span data-ttu-id="098e6-208">Değiştirmek için konumsal parametresi `powershell.exe` gelen `-Command` için `-File` [#4019](https://github.com/PowerShell/PowerShell/issues/4019)</span><span class="sxs-lookup"><span data-stu-id="098e6-208">Change positional parameter for `powershell.exe` from `-Command` to `-File` [#4019](https://github.com/PowerShell/PowerShell/issues/4019)</span></span>

<span data-ttu-id="098e6-209">Windows dışı platformlarda shebang'i PowerShell kullanımını etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="098e6-209">Enable shebang use of PowerShell on non-Windows platforms.</span></span> <span data-ttu-id="098e6-210">Başka bir deyişle, UNIX tabanlı sistemlerde PowerShell çağıracaktır bir komut dosyası yürütülebilir yapabilirsiniz açıkça çağırmak yerine otomatik olarak `pwsh`.</span><span class="sxs-lookup"><span data-stu-id="098e6-210">This means on Unix based systems, you can make a script executable that would invoke PowerShell automatically rather than explicitly invoking `pwsh`.</span></span> <span data-ttu-id="098e6-211">Ayrıca gibi şeyler yapmak, yani `powershell foo.ps1` veya `powershell fooScript` belirtmeden `-File`.</span><span class="sxs-lookup"><span data-stu-id="098e6-211">This also means that you can now do things like `powershell foo.ps1` or `powershell fooScript` without specifying `-File`.</span></span> <span data-ttu-id="098e6-212">Ancak, bu değişiklik hemen açıkça belirttiğiniz gerektirir `-c` veya `-Command` yapma çalışırken `powershell.exe Get-Command`.</span><span class="sxs-lookup"><span data-stu-id="098e6-212">However, this change now requires that you explicitly specify `-c` or `-Command` when trying to do things like `powershell.exe Get-Command`.</span></span>

### <a name="implement-unicode-escape-parsing-3958httpsgithubcompowershellpowershellissues3958"></a><span data-ttu-id="098e6-213">Unicode kaçış ayrıştırma uygulamak [#3958](https://github.com/PowerShell/PowerShell/issues/3958)</span><span class="sxs-lookup"><span data-stu-id="098e6-213">Implement Unicode escape parsing [#3958](https://github.com/PowerShell/PowerShell/issues/3958)</span></span>

<span data-ttu-id="098e6-214">`` `u####`` veya `` `u{####}`` karşılık gelen bir Unicode karakter için dönüştürülür.</span><span class="sxs-lookup"><span data-stu-id="098e6-214">`` `u####`` or `` `u{####}`` is converted to the corresponding Unicode character.</span></span> <span data-ttu-id="098e6-215">Bir sabit değer çıkış `` `u``, kaçış vurgulamasını belirtir: ``` ``u```.</span><span class="sxs-lookup"><span data-stu-id="098e6-215">To output a literal `` `u``, escape the backtick: ``` ``u```.</span></span>

### <a name="change-new-modulemanifest-encoding-to-utf8nobom-on-non-windows-platforms-3940httpsgithubcompowershellpowershellissues3940"></a><span data-ttu-id="098e6-216">Değişiklik `New-ModuleManifest` kodlamasını `UTF8NoBOM` Windows dışı platformlarda [#3940](https://github.com/PowerShell/PowerShell/issues/3940)</span><span class="sxs-lookup"><span data-stu-id="098e6-216">Change `New-ModuleManifest` encoding to `UTF8NoBOM` on non-Windows platforms [#3940](https://github.com/PowerShell/PowerShell/issues/3940)</span></span>

<span data-ttu-id="098e6-217">Daha önce `New-ModuleManifest` Linux araçları için sorun oluşturma, BOM ile UTF-16 psd1 bildirimleri oluşturur.</span><span class="sxs-lookup"><span data-stu-id="098e6-217">Previously, `New-ModuleManifest` creates psd1 manifests in UTF-16 with BOM, creating a problem for Linux tools.</span></span> <span data-ttu-id="098e6-218">Bu değişiklik, kodlama değişiklikleri `New-ModuleManifest` Windows dışı platformlarda UTF (hiçbir BOM) olacak şekilde.</span><span class="sxs-lookup"><span data-stu-id="098e6-218">This breaking change changes the encoding of `New-ModuleManifest` to be UTF (no BOM) in non-Windows platforms.</span></span>

### <a name="prevent-get-childitem-from-recursing-into-symlinks-1875-3780httpsgithubcompowershellpowershellissues3780"></a><span data-ttu-id="098e6-219">Engelleme `Get-ChildItem` çözümlemeyin recursing gelen (#1875).</span><span class="sxs-lookup"><span data-stu-id="098e6-219">Prevent `Get-ChildItem` from recursing into symlinks (#1875).</span></span> [<span data-ttu-id="098e6-220">#3780</span><span class="sxs-lookup"><span data-stu-id="098e6-220">#3780</span></span>](https://github.com/PowerShell/PowerShell/issues/3780)

<span data-ttu-id="098e6-221">Bu değişiklik getirir `Get-ChildItem` UNIX ayarlarına uygun olarak daha fazla `ls -r` ve Windows `dir /s` yerel komutları.</span><span class="sxs-lookup"><span data-stu-id="098e6-221">This change brings `Get-ChildItem` more in line with the Unix `ls -r` and the Windows `dir /s` native commands.</span></span> <span data-ttu-id="098e6-222">Belirtilen komutları gibi cmdlet özyineleme sırasında bulunan dizinler için simgesel bağlantılar görüntüler, ancak bunları recurse değil.</span><span class="sxs-lookup"><span data-stu-id="098e6-222">Like the mentioned commands, the cmdlet displays symbolic links to directories found during recursion, but does not recurse into them.</span></span>

### <a name="fix-get-content--delimiter-to-not-include-the-delimiter-in-the-returned-lines-3706httpsgithubcompowershellpowershellissues3706"></a><span data-ttu-id="098e6-223">Düzeltme `Get-Content -Delimiter` sınırlayıcı döndürülen satırları içermeyecek şekilde [#3706](https://github.com/PowerShell/PowerShell/issues/3706)</span><span class="sxs-lookup"><span data-stu-id="098e6-223">Fix `Get-Content -Delimiter` to not include the delimiter in the returned lines [#3706](https://github.com/PowerShell/PowerShell/issues/3706)</span></span>

<span data-ttu-id="098e6-224">Kullanırken daha önce çıkış `Get-Content -Delimiter` tutarsız ve daha fazla sınırlayıcı kaldırmak için veri işleme gerektiği şekilde kullanışsız.</span><span class="sxs-lookup"><span data-stu-id="098e6-224">Previously, the output while using `Get-Content -Delimiter` was inconsistent and inconvenient as it required further processing of the data to remove the delimiter.</span></span> <span data-ttu-id="098e6-225">Bu değişiklik, sınırlayıcı döndürülen satırları kaldırır.</span><span class="sxs-lookup"><span data-stu-id="098e6-225">This change removes the delimiter in returned lines.</span></span>

### <a name="implement-format-hex-in-c-3320httpsgithubcompowershellpowershellissues3320"></a><span data-ttu-id="098e6-226">Biçimi onaltılık olarak uygulamak C# [#3320](https://github.com/PowerShell/PowerShell/issues/3320)</span><span class="sxs-lookup"><span data-stu-id="098e6-226">Implement Format-Hex in C# [#3320](https://github.com/PowerShell/PowerShell/issues/3320)</span></span>

<span data-ttu-id="098e6-227">`-Raw` Parametredir şimdi bir "İşlemsiz" (hiçbir şey yapmasa unutmayın).</span><span class="sxs-lookup"><span data-stu-id="098e6-227">The `-Raw` parameter is now a "no-op" (in that it does nothing).</span></span> <span data-ttu-id="098e6-228">Tüm çıktı gösterilecek olan kendi türü için bayt hepsini içerir numaralarını temsil ileride (ne `-Raw` parametresi resmi önce bu değişiklik yaptığını).</span><span class="sxs-lookup"><span data-stu-id="098e6-228">Going forward all of the output will be displayed with a true representation of numbers that includes all of the bytes for its type (what the `-Raw` parameter was formally doing prior to this change).</span></span>

### <a name="powershell-as-a-default-shell-doesnt-work-with-script-command-3319httpsgithubcompowershellpowershellissues3319"></a><span data-ttu-id="098e6-229">PowerShell varsayılan kabuğunu olarak komut ile işe yaramazsa [#3319](https://github.com/PowerShell/PowerShell/issues/3319)</span><span class="sxs-lookup"><span data-stu-id="098e6-229">PowerShell as a default shell doesn't work with script command [#3319](https://github.com/PowerShell/PowerShell/issues/3319)</span></span>

<span data-ttu-id="098e6-230">İsteğe bağlı olarak, UNIX için Kabukları kabul etmek bir kuralı olan `-i` etkileşimli bir kabuk ve birçok araçları bu davranışı beklediğiniz için (`script` örneğin ve PowerShell varsayılan kabuğunu ayarlama) ve kabuğunda çağırır `-i` geçin.</span><span class="sxs-lookup"><span data-stu-id="098e6-230">On Unix, it is a convention for shells to accept `-i` for an interactive shell and many tools expect this behavior (`script` for example, and when setting PowerShell as the default shell) and calls the shell with the `-i` switch.</span></span> <span data-ttu-id="098e6-231">Bu değişiklik, bozucu `-i` kısa ele eşleştirmek için daha önce kullanılabilir `-inputformat`, olması gerekir böylece `-in`.</span><span class="sxs-lookup"><span data-stu-id="098e6-231">This change is breaking in that `-i` previously could be used as short hand to match `-inputformat`, which now needs to be `-in`.</span></span>

### <a name="typo-fix-in-get-computerinfo-property-name-3167httpsgithubcompowershellpowershellissues3167"></a><span data-ttu-id="098e6-232">Get-Computerınfo özellik adında yazım hatası düzeltme [#3167](https://github.com/PowerShell/PowerShell/issues/3167)</span><span class="sxs-lookup"><span data-stu-id="098e6-232">Typo fix in Get-ComputerInfo property name [#3167](https://github.com/PowerShell/PowerShell/issues/3167)</span></span>

<span data-ttu-id="098e6-233">`BiosSerialNumber` olarak yanlış `BiosSeralNumber` ve yazımını için değiştirildi.</span><span class="sxs-lookup"><span data-stu-id="098e6-233">`BiosSerialNumber` was misspelled as `BiosSeralNumber` and has been changed to the correct spelling.</span></span>

### <a name="add-get-stringhash-and-get-filehash-cmdlets-3024httpsgithubcompowershellpowershellissues3024"></a><span data-ttu-id="098e6-234">Ekleme `Get-StringHash` ve `Get-FileHash` cmdlet'leri [#3024](https://github.com/PowerShell/PowerShell/issues/3024)</span><span class="sxs-lookup"><span data-stu-id="098e6-234">Add `Get-StringHash` and `Get-FileHash` cmdlets [#3024](https://github.com/PowerShell/PowerShell/issues/3024)</span></span>

<span data-ttu-id="098e6-235">Bu değişiklik, bazı karma algoritmaları Corefx'te tarafından desteklenmiyor, bu nedenle bunlar artık kullanılabilir olan:</span><span class="sxs-lookup"><span data-stu-id="098e6-235">This change is that some hash algorithms are not supported by CoreFX, therefore they are no longer available:</span></span>

- `MACTripleDES`
- `RIPEMD160`

### <a name="add-validation-on-get--cmdlets-where-passing-null-returns-all-objects-instead-of-error-2672httpsgithubcompowershellpowershellissues2672"></a><span data-ttu-id="098e6-236">Doğrulama eklemek `Get-*` $null geçirme döndüğü hatası yerine tüm nesneler cmdlet'lerini [#2672](https://github.com/PowerShell/PowerShell/issues/2672)</span><span class="sxs-lookup"><span data-stu-id="098e6-236">Add validation on `Get-*` cmdlets where passing $null returns all objects instead of error [#2672](https://github.com/PowerShell/PowerShell/issues/2672)</span></span>

<span data-ttu-id="098e6-237">Geçirme `$null` herhangi bir hata şu anda oluşturur:</span><span class="sxs-lookup"><span data-stu-id="098e6-237">Passing `$null` to any of the following now throws an error:</span></span>

- `Get-Credential -UserName`
- `Get-Event -SourceIdentifier`
- `Get-EventSubscriber -SourceIdentifier`
- `Get-Help -Name`
- `Get-PSBreakpoint -Script`
- `Get-PSProvider -PSProvider`
- `Get-PSSessionConfiguration -Name`
- `Get-PSSnapin -Name`
- `Get-Runspace -Name`
- `Get-RunspaceDebug -RunspaceName`
- `Get-Service -Name`
- `Get-TraceSource -Name`
- `Get-Variable -Name`
- `Get-WmiObject -Class`
- `Get-WmiObject -Property`

### <a name="add-support-w3c-extended-log-file-format-in-import-csv-2482httpsgithubcompowershellpowershellissues2482"></a><span data-ttu-id="098e6-238">Ekleme desteği W3C Genişletilmiş günlük dosyası biçimi ' `Import-Csv` [#2482](https://github.com/PowerShell/PowerShell/issues/2482)</span><span class="sxs-lookup"><span data-stu-id="098e6-238">Add support W3C Extended Log File Format in `Import-Csv` [#2482](https://github.com/PowerShell/PowerShell/issues/2482)</span></span>

<span data-ttu-id="098e6-239">Daha önce `Import-Csv` cmdlet'i, doğrudan W3C Genişletilmiş günlük biçiminde günlük dosyalarını içeri aktarmak için kullanılamaz ve başka bir işlem gerekli olacaktır.</span><span class="sxs-lookup"><span data-stu-id="098e6-239">Previously, the `Import-Csv` cmdlet cannot be used to directly import the log files in W3C extended log format and additional action would be required.</span></span> <span data-ttu-id="098e6-240">Bu değişiklik, W3C Genişletilmiş günlük biçimini desteklenir.</span><span class="sxs-lookup"><span data-stu-id="098e6-240">With this change, W3C extended log format is supported.</span></span>

### <a name="parameter-binding-problem-with-valuefromremainingarguments-in-ps-functions-2035httpsgithubcompowershellpowershellissues2035"></a><span data-ttu-id="098e6-241">Parametre bağlama sorun `ValueFromRemainingArguments` PS işlevlerde [#2035](https://github.com/PowerShell/PowerShell/issues/2035)</span><span class="sxs-lookup"><span data-stu-id="098e6-241">Parameter binding problem with `ValueFromRemainingArguments` in PS functions [#2035](https://github.com/PowerShell/PowerShell/issues/2035)</span></span>

<span data-ttu-id="098e6-242">`ValueFromRemainingArguments` değerleri yerine tek bir dizi olarak döndürür kendisi değer artık bir dizidir.</span><span class="sxs-lookup"><span data-stu-id="098e6-242">`ValueFromRemainingArguments` now returns the values as an array instead of a single value which itself is an array.</span></span>

### <a name="buildversion-is-removed-from-psversiontable-1415httpsgithubcompowershellpowershellissues1415"></a><span data-ttu-id="098e6-243">`BuildVersion` kaldırılır `$PSVersionTable` [#1415](https://github.com/PowerShell/PowerShell/issues/1415)</span><span class="sxs-lookup"><span data-stu-id="098e6-243">`BuildVersion` is removed from `$PSVersionTable` [#1415](https://github.com/PowerShell/PowerShell/issues/1415)</span></span>

<span data-ttu-id="098e6-244">Kaldırma `BuildVersion` özelliğinden `$PSVersionTable`.</span><span class="sxs-lookup"><span data-stu-id="098e6-244">Remove the `BuildVersion` property from `$PSVersionTable`.</span></span> <span data-ttu-id="098e6-245">Bu özellik Windows yapı sürümüne bağlı.</span><span class="sxs-lookup"><span data-stu-id="098e6-245">This property was tied to the Windows build version.</span></span> <span data-ttu-id="098e6-246">Bunun yerine kullanmanızı öneriyoruz `GitCommitId` PowerShell Core tam derleme sürümü almak için.</span><span class="sxs-lookup"><span data-stu-id="098e6-246">Instead, we recommend that you use `GitCommitId` to retrieve the exact build version of PowerShell Core.</span></span>

### <a name="changes-to-web-cmdlets"></a><span data-ttu-id="098e6-247">Değişiklikleri Web cmdlet'leri</span><span class="sxs-lookup"><span data-stu-id="098e6-247">Changes to Web Cmdlets</span></span>

<span data-ttu-id="098e6-248">Temel .NET API Web cmdlet'lerinin değiştirildi `System.Net.Http.HttpClient`.</span><span class="sxs-lookup"><span data-stu-id="098e6-248">The underlying .NET API of the Web Cmdlets has been changed to `System.Net.Http.HttpClient`.</span></span> <span data-ttu-id="098e6-249">Bu değişiklik, birçok avantaj sunar.</span><span class="sxs-lookup"><span data-stu-id="098e6-249">This change provides many benefits.</span></span> <span data-ttu-id="098e6-250">Ancak, bu değişiklikle birlikte Internet Explorer ile birlikte çalışabilirlik eksikliği sonuçlandı içindeki çeşitli bozucu değişiklikler `Invoke-WebRequest` ve `Invoke-RestMethod`.</span><span class="sxs-lookup"><span data-stu-id="098e6-250">However, this change along with a lack of interoperability with Internet Explorer have resulted in several breaking changes within `Invoke-WebRequest` and `Invoke-RestMethod`.</span></span>

- <span data-ttu-id="098e6-251">`Invoke-WebRequest` Şimdi temel HTML Ayrıştırma yalnızca destekler.</span><span class="sxs-lookup"><span data-stu-id="098e6-251">`Invoke-WebRequest` now supports basic HTML Parsing only.</span></span> <span data-ttu-id="098e6-252">`Invoke-WebRequest` her zaman döndüren bir `BasicHtmlWebResponseObject` nesne.</span><span class="sxs-lookup"><span data-stu-id="098e6-252">`Invoke-WebRequest` always returns a `BasicHtmlWebResponseObject` object.</span></span> <span data-ttu-id="098e6-253">`ParsedHtml` Ve `Forms` özellikleri kaldırıldı.</span><span class="sxs-lookup"><span data-stu-id="098e6-253">The `ParsedHtml` and `Forms` properties have been removed.</span></span>
- <span data-ttu-id="098e6-254">`BasicHtmlWebResponseObject.Headers` değerler şimdi `String[]` yerine `String`.</span><span class="sxs-lookup"><span data-stu-id="098e6-254">`BasicHtmlWebResponseObject.Headers` values are now `String[]` instead of `String`.</span></span>
- <span data-ttu-id="098e6-255">`BasicHtmlWebResponseObject.BaseResponse` artık bir `System.Net.Http.HttpResponseMessage` nesne.</span><span class="sxs-lookup"><span data-stu-id="098e6-255">`BasicHtmlWebResponseObject.BaseResponse` is now a `System.Net.Http.HttpResponseMessage` object.</span></span>
- <span data-ttu-id="098e6-256">`Response` Web Cmdlet özel durum özelliği, artık bir `System.Net.Http.HttpResponseMessage` nesne.</span><span class="sxs-lookup"><span data-stu-id="098e6-256">The `Response` property on Web Cmdlet exceptions is now a `System.Net.Http.HttpResponseMessage` object.</span></span>
- <span data-ttu-id="098e6-257">Katı RFC üstbilgi ayrıştırma, artık varsayılan `-Headers` ve `-UserAgent` parametresi.</span><span class="sxs-lookup"><span data-stu-id="098e6-257">Strict RFC header parsing is now default for the `-Headers` and `-UserAgent` parameter.</span></span> <span data-ttu-id="098e6-258">Bu ile atlanabilir `-SkipHeaderValidation`.</span><span class="sxs-lookup"><span data-stu-id="098e6-258">This can be bypassed with `-SkipHeaderValidation`.</span></span>
- <span data-ttu-id="098e6-259">`file://` ve `ftp://` URI düzenleri artık desteklenmiyor.</span><span class="sxs-lookup"><span data-stu-id="098e6-259">`file://` and `ftp://` URI schemes are no longer supported.</span></span>
- <span data-ttu-id="098e6-260">`System.Net.ServicePointManager` ayarları artık dikkate alınır.</span><span class="sxs-lookup"><span data-stu-id="098e6-260">`System.Net.ServicePointManager` settings are no longer honored.</span></span>
- <span data-ttu-id="098e6-261">Var. şu anda hiçbir sertifika tabanlı kimlik doğrulaması macOS üzerinde</span><span class="sxs-lookup"><span data-stu-id="098e6-261">There is currently no certificate based authentication available on macOS.</span></span>
- <span data-ttu-id="098e6-262">Kullanım `-Credential` üzerinden bir `http://` URI hataya neden olur.</span><span class="sxs-lookup"><span data-stu-id="098e6-262">Use of `-Credential` over an `http://` URI will result in an error.</span></span> <span data-ttu-id="098e6-263">Kullanım bir `https://` URI veya tedarik `-AllowUnencryptedAuthentication` hata bastırmak için parametre.</span><span class="sxs-lookup"><span data-stu-id="098e6-263">Use an `https://` URI or supply the `-AllowUnencryptedAuthentication` parameter to suppress the error.</span></span>
- <span data-ttu-id="098e6-264">`-MaximumRedirection` Şimdi yeniden yönlendirme denemeleri son yeniden yönlendirme sonuçlarını döndürmek yerine belirtilen sınırı aşan bir sonlandırma hatası oluşturur.</span><span class="sxs-lookup"><span data-stu-id="098e6-264">`-MaximumRedirection` now produces a terminating error when redirection attempts exceed the provided limit instead of returning the results of the last redirection.</span></span>
