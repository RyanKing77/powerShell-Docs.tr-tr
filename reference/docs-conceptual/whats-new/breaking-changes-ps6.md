---
ms.date: 05/17/2018
keywords: PowerShell, çekirdek
title: PowerShell 6,0 için son değişiklikler
ms.openlocfilehash: 186e55c1ac46ce3fc172df18995f8c15d9eeb8eb
ms.sourcegitcommit: 118eb294d5a84a772e6449d42a9d9324e18ef6b9
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 07/26/2019
ms.locfileid: "67843933"
---
# <a name="breaking-changes-for-powershell-60"></a><span data-ttu-id="899ad-103">PowerShell 6,0 için son değişiklikler</span><span class="sxs-lookup"><span data-stu-id="899ad-103">Breaking Changes for PowerShell 6.0</span></span>

## <a name="features-no-longer-available-in-powershell-core"></a><span data-ttu-id="899ad-104">PowerShell Core 'da artık kullanılamayan özellikler</span><span class="sxs-lookup"><span data-stu-id="899ad-104">Features no longer available in PowerShell Core</span></span>

### <a name="powershell-workflow"></a><span data-ttu-id="899ad-105">PowerShell iş akışı</span><span class="sxs-lookup"><span data-stu-id="899ad-105">PowerShell Workflow</span></span>

<span data-ttu-id="899ad-106">[PowerShell Iş akışı][workflow] , Windows PowerShell 'de, uzun süreli veya paralel görevler için sağlam runbook 'ların oluşturulmasına izin veren [Windows Workflow Foundation (WF)][workflow-foundation] üzerinde derleme yapan bir özelliktir.</span><span class="sxs-lookup"><span data-stu-id="899ad-106">[PowerShell Workflow][workflow] is a feature in Windows PowerShell that builds on top of [Windows Workflow Foundation (WF)][workflow-foundation] that enables the creation of robust runbooks for long-running or parallelized tasks.</span></span>

<span data-ttu-id="899ad-107">.NET Core 'daki Windows Workflow Foundation desteğinin olmamasından dolayı PowerShell Core 'da PowerShell Iş akışını desteklemeye devam eteceğiz.</span><span class="sxs-lookup"><span data-stu-id="899ad-107">Due to the lack of support for Windows Workflow Foundation in .NET Core, we will not continue to support PowerShell Workflow in PowerShell Core.</span></span>

<span data-ttu-id="899ad-108">Gelecekte PowerShell Iş akışına gerek olmadan PowerShell dilinde yerel paralellik/eşzamanlılık özelliğini etkinleştirmek istiyoruz.</span><span class="sxs-lookup"><span data-stu-id="899ad-108">In the future, we would like to enable native parallelism/concurrency in the PowerShell language without the need for PowerShell Workflow.</span></span>

[workflow]: https://docs.microsoft.com/powershell/scripting/core-powershell/workflows-guide
[workflow-foundation]: https://docs.microsoft.com/dotnet/framework/windows-workflow-foundation/

### <a name="custom-snap-ins"></a><span data-ttu-id="899ad-109">Özel ek bileşenler</span><span class="sxs-lookup"><span data-stu-id="899ad-109">Custom snap-ins</span></span>

<span data-ttu-id="899ad-110">PowerShell [ek bileşenleri][snapin] , PowerShell topluluğunda geniş kapsamlı benimseme gerektirmeyen PowerShell modüllerine yönelik bir öncülü vardır.</span><span class="sxs-lookup"><span data-stu-id="899ad-110">[PowerShell snap-ins][snapin] are a predecessor to PowerShell modules that do not have widespread adoption in the PowerShell community.</span></span>

<span data-ttu-id="899ad-111">Ek bileşenlerin, topluluk içindeki kullanım eksikliğinden ve bu kullanıcıların topluluk içindeki kullanım eksikliğinden dolayı artık PowerShell Core 'da özel ek bileşenleri desteklemiyoruz.</span><span class="sxs-lookup"><span data-stu-id="899ad-111">Due to the complexity of supporting snap-ins and their lack of usage in the community, we no longer support custom snap-ins in PowerShell Core.</span></span>

<span data-ttu-id="899ad-112">Günümüzde, Windows ve Windows `ActiveDirectory` Server `DnsClient` 'daki ve modülleri bu şekilde kesilir.</span><span class="sxs-lookup"><span data-stu-id="899ad-112">Today, this breaks the `ActiveDirectory` and `DnsClient` modules in Windows and Windows Server.</span></span>

[snapin]: https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_pssnapins

### <a name="wmi-v1-cmdlets"></a><span data-ttu-id="899ad-113">WMI v1 cmdlet 'leri</span><span class="sxs-lookup"><span data-stu-id="899ad-113">WMI v1 cmdlets</span></span>

<span data-ttu-id="899ad-114">İki WMI tabanlı modül kümesini destekleme karmaşıklığı nedeniyle, WMI v1 cmdlet 'lerini PowerShell Core 'dan kaldırdık:</span><span class="sxs-lookup"><span data-stu-id="899ad-114">Due to the complexity of supporting two sets of WMI-based modules, we removed the WMI v1 cmdlets from PowerShell Core:</span></span>

- `Get-WmiObject`
- `Invoke-WmiMethod`
- `Register-WmiEvent`
- `Set-WmiInstance`

<span data-ttu-id="899ad-115">Bunun yerine, yeni işlevlerle aynı işlevselliği ve yeniden tasarlanan bir sözdizimi sağlayan CıM (diğer adıyla WMI v2) cmdlet 'lerini kullanmanızı öneririz:</span><span class="sxs-lookup"><span data-stu-id="899ad-115">Instead, we recommend that you the use the CIM (aka WMI v2) cmdlets which provide the same functionality with new functionality and a redesigned syntax:</span></span>

- `Get-CimAssociatedInstance`
- `Get-CimClass`
- `Get-CimInstance`
- `Get-CimSession`
- `Invoke-CimMethod`
- `New-CimInstance`
- `New-CimSession`
- `New-CimSessionOption`
- `Register-CimIndicationEvent`
- `Remove-CimInstance`
- `Remove-CimSession`
- `Set-CimInstance`

### <a name="microsoftpowershelllocalaccounts"></a><span data-ttu-id="899ad-116">Microsoft. PowerShell. LocalAccounts</span><span class="sxs-lookup"><span data-stu-id="899ad-116">Microsoft.PowerShell.LocalAccounts</span></span>

<span data-ttu-id="899ad-117">Desteklenmeyen API 'lerin kullanılması nedeniyle, `Microsoft.PowerShell.LocalAccounts` daha iyi bir çözüm bulunana kadar PowerShell Core 'dan kaldırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="899ad-117">Due to the use of unsupported APIs, `Microsoft.PowerShell.LocalAccounts` has been removed from PowerShell Core until a better solution is found.</span></span>

### <a name="-computer-cmdlets"></a><span data-ttu-id="899ad-118">`*-Computer`öğelerini</span><span class="sxs-lookup"><span data-stu-id="899ad-118">`*-Computer` cmdlets</span></span>

<span data-ttu-id="899ad-119">Desteklenmeyen API 'lerin kullanılması nedeniyle, daha iyi bir çözüm bulunana kadar aşağıdaki cmdlet 'ler PowerShell çekirdekden kaldırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="899ad-119">Due to the use of unsupported APIs, the following cmdlets have been removed from PowerShell Core until a better solution is found.</span></span>

- <span data-ttu-id="899ad-120">Add-Computer</span><span class="sxs-lookup"><span data-stu-id="899ad-120">Add-Computer</span></span>
- <span data-ttu-id="899ad-121">Checkpoint-Computer</span><span class="sxs-lookup"><span data-stu-id="899ad-121">Checkpoint-Computer</span></span>
- <span data-ttu-id="899ad-122">Remove-Computer</span><span class="sxs-lookup"><span data-stu-id="899ad-122">Remove-Computer</span></span>
- <span data-ttu-id="899ad-123">Geri yükleme-bilgisayar</span><span class="sxs-lookup"><span data-stu-id="899ad-123">Restore-Computer</span></span>

### <a name="-counter-cmdlets"></a><span data-ttu-id="899ad-124">`*-Counter`öğelerini</span><span class="sxs-lookup"><span data-stu-id="899ad-124">`*-Counter` cmdlets</span></span>

<span data-ttu-id="899ad-125">Desteklenmeyen API `*-Counter` 'lerin kullanılması nedeniyle, daha iyi bir çözüm bulunana kadar PowerShell Core 'dan kaldırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="899ad-125">Due to the use of unsupported APIs, the `*-Counter` has been removed from PowerShell Core until a better solution is found.</span></span>

### <a name="-eventlog-cmdlets"></a><span data-ttu-id="899ad-126">`*-EventLog`öğelerini</span><span class="sxs-lookup"><span data-stu-id="899ad-126">`*-EventLog` cmdlets</span></span>

<span data-ttu-id="899ad-127">Desteklenmeyen API `*-EventLog` 'lerin kullanılması nedeniyle, PowerShell Core 'dan kaldırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="899ad-127">Due to the use of unsupported APIs, the `*-EventLog` has been removed from PowerShell Core.</span></span> <span data-ttu-id="899ad-128">daha iyi bir çözüm bulunana kadar.</span><span class="sxs-lookup"><span data-stu-id="899ad-128">until a better solution is found.</span></span> <span data-ttu-id="899ad-129">`Get-WinEvent`ve `Create-WinEvent` Windows 'da olayları almak ve oluşturmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="899ad-129">`Get-WinEvent` and `Create-WinEvent` are available to get and create events on Windows.</span></span>

## <a name="enginelanguage-changes"></a><span data-ttu-id="899ad-130">Motor/dil değişiklikleri</span><span class="sxs-lookup"><span data-stu-id="899ad-130">Engine/language changes</span></span>

### <a name="rename-powershellexe-to-pwshexe-5101httpsgithubcompowershellpowershellissues5101"></a><span data-ttu-id="899ad-131">`powershell.exe` [#5101](https://github.com/PowerShell/PowerShell/issues/5101) olarak `pwsh.exe` yeniden adlandır</span><span class="sxs-lookup"><span data-stu-id="899ad-131">Rename `powershell.exe` to `pwsh.exe` [#5101](https://github.com/PowerShell/PowerShell/issues/5101)</span></span>

<span data-ttu-id="899ad-132">Kullanıcılara PowerShell Core 'u Windows üzerinde (Windows PowerShell 'in aksine) çağırmak için belirleyici bir yöntem sağlamak üzere, PowerShell Core ikilisi Windows ve `pwsh.exe` `pwsh` Windows dışı platformlarda olarak değiştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="899ad-132">In order to give users a deterministic way to call PowerShell Core on Windows (as opposed to Windows PowerShell), the PowerShell Core binary was changed to `pwsh.exe` on Windows and `pwsh` on non-Windows platforms.</span></span>

<span data-ttu-id="899ad-133">Kısaltılmış ad, Windows dışı platformlarda kabukların adlandırılmasıyla de tutarlıdır.</span><span class="sxs-lookup"><span data-stu-id="899ad-133">The shortened name is also consistent with naming of shells on non-Windows platforms.</span></span>

### <a name="dont-insert-line-breaks-to-output-except-for-tables-5193httpsgithubcompowershellpowershellissues5193"></a><span data-ttu-id="899ad-134">Çıktıya satır sonları eklemeyin (tablolar hariç) [#5193](https://github.com/PowerShell/PowerShell/issues/5193)</span><span class="sxs-lookup"><span data-stu-id="899ad-134">Don't insert line breaks to output (except for tables) [#5193](https://github.com/PowerShell/PowerShell/issues/5193)</span></span>

<span data-ttu-id="899ad-135">Daha önce, çıkış konsolun genişliğine hizalanır ve konsolun bitiş genişliğine göre satır sonları eklenmiştir, bu da terminalin yeniden boyutlandırılması durumunda çıktının beklendiği gibi yeniden biçimlendirilmediği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="899ad-135">Previously, output was aligned to the width of the console and line breaks were added at the end width of the console, meaning the output didn't get reformatted as expected if the terminal was resized.</span></span> <span data-ttu-id="899ad-136">Sütunları hizalı tutmak için satır sonları gerekli olduğundan bu değişiklik tablolara uygulanmadı.</span><span class="sxs-lookup"><span data-stu-id="899ad-136">This change was not applied to tables, as the line breaks are necessary to keep the columns aligned.</span></span>

### <a name="skip-null-element-check-for-collections-with-a-value-type-element-type-5432httpsgithubcompowershellpowershellissues5432"></a><span data-ttu-id="899ad-137">Değer türü öğe türü olan koleksiyonlar için null öğe denetimini atlayın [#5432](https://github.com/PowerShell/PowerShell/issues/5432)</span><span class="sxs-lookup"><span data-stu-id="899ad-137">Skip null-element check for collections with a value-type element type [#5432](https://github.com/PowerShell/PowerShell/issues/5432)</span></span>

<span data-ttu-id="899ad-138">`Mandatory` Parametresi`ValidateNotNull` ve öznitelikleriiçin,koleksiyonunöğetürüdeğertüründeisenullöğedenetiminiatlayın.`ValidateNotNullOrEmpty`</span><span class="sxs-lookup"><span data-stu-id="899ad-138">For the `Mandatory` parameter and `ValidateNotNull` and `ValidateNotNullOrEmpty` attributes, skip the null-element check if the collection's element type is value type.</span></span>

### <a name="change-outputencoding-to-use-utf-8-nobom-encoding-rather-than-ascii-5369httpsgithubcompowershellpowershellissues5369"></a><span data-ttu-id="899ad-139">ASCII `$OutputEncoding` [#5369](https://github.com/PowerShell/PowerShell/issues/5369) yerine `UTF-8 NoBOM` kodlamayı kullanacak şekilde değiştirin</span><span class="sxs-lookup"><span data-stu-id="899ad-139">Change `$OutputEncoding` to use `UTF-8 NoBOM` encoding rather than ASCII [#5369](https://github.com/PowerShell/PowerShell/issues/5369)</span></span>

<span data-ttu-id="899ad-140">Önceki kodlama, ASCII (7 bit), bazı durumlarda çıkışın yanlış şekilde değişmeye neden olur.</span><span class="sxs-lookup"><span data-stu-id="899ad-140">The previous encoding, ASCII (7-bit), would result in incorrect alteration of the output in some cases.</span></span> <span data-ttu-id="899ad-141">Bu değişiklik varsayılan hale `UTF-8 NoBOM` gelir, ancak çoğu araç ve işletim sistemi tarafından desteklenen bir kodlama ile Unicode çıktısını korur.</span><span class="sxs-lookup"><span data-stu-id="899ad-141">This change is to make `UTF-8 NoBOM` default, which preserves Unicode output with an encoding supported by most tools and operating systems.</span></span>

### <a name="remove-allscope-from-most-default-aliases-5268httpsgithubcompowershellpowershellissues5268"></a><span data-ttu-id="899ad-142">En `AllScope` çok varsayılan diğer adlarla Kaldır [#5268](https://github.com/PowerShell/PowerShell/issues/5268)</span><span class="sxs-lookup"><span data-stu-id="899ad-142">Remove `AllScope` from most default aliases [#5268](https://github.com/PowerShell/PowerShell/issues/5268)</span></span>

<span data-ttu-id="899ad-143">Kapsam oluşturmayı hızlandırmak için, `AllScope` en çok varsayılan diğer adlarla kaldırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="899ad-143">To speed up scope creation, `AllScope` was removed from most default aliases.</span></span> <span data-ttu-id="899ad-144">`AllScope`aramanın daha hızlı olduğu bazı sık kullanılan diğer adlar için ayrılmıştı.</span><span class="sxs-lookup"><span data-stu-id="899ad-144">`AllScope` was left for a few frequently used aliases where the lookup was faster.</span></span>

### <a name="-verbose-and--debug-no-longer-overrides-erroractionpreference-5113httpsgithubcompowershellpowershellissues5113"></a><span data-ttu-id="899ad-145">`-Verbose`artık geçersiz `$ErrorActionPreference` kılınmayacak [#5113](https://github.com/PowerShell/PowerShell/issues/5113) `-Debug`</span><span class="sxs-lookup"><span data-stu-id="899ad-145">`-Verbose` and `-Debug` no longer overrides `$ErrorActionPreference` [#5113](https://github.com/PowerShell/PowerShell/issues/5113)</span></span>

<span data-ttu-id="899ad-146">Daha önce, `-Verbose` veya `-Debug` belirtilmişse davranışının `$ErrorActionPreference`üzerine gelin.</span><span class="sxs-lookup"><span data-stu-id="899ad-146">Previously, if `-Verbose` or `-Debug` were specified, it overrode the behavior of `$ErrorActionPreference`.</span></span> <span data-ttu-id="899ad-147">Bu değişiklik `-Verbose` `-Debug` ile artıkdavranışınıetkilemez.`$ErrorActionPreference`</span><span class="sxs-lookup"><span data-stu-id="899ad-147">With this change, `-Verbose` and `-Debug` no longer affect the behavior of `$ErrorActionPreference`.</span></span>

## <a name="cmdlet-changes"></a><span data-ttu-id="899ad-148">Cmdlet değişiklikleri</span><span class="sxs-lookup"><span data-stu-id="899ad-148">Cmdlet changes</span></span>

### <a name="invoke-restmethod-doesnt-return-useful-info-when-no-data-is-returned-5320httpsgithubcompowershellpowershellissues5320"></a><span data-ttu-id="899ad-149">Invoke-RestMethod hiçbir veri döndürülmediğinde yararlı bilgiler döndürmez.</span><span class="sxs-lookup"><span data-stu-id="899ad-149">Invoke-RestMethod doesn't return useful info when no data is returned.</span></span> [<span data-ttu-id="899ad-150">#5320</span><span class="sxs-lookup"><span data-stu-id="899ad-150">#5320</span></span>](https://github.com/PowerShell/PowerShell/issues/5320)

<span data-ttu-id="899ad-151">Bir API yalnızca `null`döndürdüğü zaman Invoke-RestMethod bunun yerine `$null`dize `"null"` olarak serileştiriliydi.</span><span class="sxs-lookup"><span data-stu-id="899ad-151">When an API returns just `null`, Invoke-RestMethod was serializing this as the string `"null"` instead of `$null`.</span></span> <span data-ttu-id="899ad-152">Bu değişiklik, ' deki geçerli `Invoke-RestMethod` tek değerli JSON `null` sabit `$null`değerini doğru şekilde serileştirmek için içindeki mantığı düzeltir.</span><span class="sxs-lookup"><span data-stu-id="899ad-152">This change fixes the logic in `Invoke-RestMethod` to properly serialize a valid single value JSON `null` literal as `$null`.</span></span>

### <a name="remove--protocol-from--computer-cmdlets-5277httpsgithubcompowershellpowershellissues5277"></a><span data-ttu-id="899ad-153">Cmdlet `-Protocol` 'lerden `*-Computer` Kaldır [#5277](https://github.com/PowerShell/PowerShell/issues/5277)</span><span class="sxs-lookup"><span data-stu-id="899ad-153">Remove `-Protocol` from `*-Computer` cmdlets [#5277](https://github.com/PowerShell/PowerShell/issues/5277)</span></span>

<span data-ttu-id="899ad-154">Corefx 'te RPC uzaktan iletişim sorunları (özellikle Windows dışı platformlarda) ve PowerShell 'de tutarlı bir uzaktan iletişim deneyimi sağlamak nedeniyle, `-Protocol` parametre `\*-Computer` cmdlet 'lerden kaldırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="899ad-154">Due to issues with RPC remoting in CoreFX (particularly on non-Windows platforms) and ensuring a consistent remoting experience in PowerShell, the `-Protocol` parameter was removed from the `\*-Computer` cmdlets.</span></span> <span data-ttu-id="899ad-155">Uzaktan erişim için DCOM artık desteklenmiyor.</span><span class="sxs-lookup"><span data-stu-id="899ad-155">DCOM is no longer supported for remoting.</span></span> <span data-ttu-id="899ad-156">Aşağıdaki cmdlet 'ler yalnızca WSMAN uzaktan iletişimini destekler:</span><span class="sxs-lookup"><span data-stu-id="899ad-156">The following cmdlets only support WSMAN remoting:</span></span>

- <span data-ttu-id="899ad-157">Yeniden adlandır-bilgisayar</span><span class="sxs-lookup"><span data-stu-id="899ad-157">Rename-Computer</span></span>
- <span data-ttu-id="899ad-158">Restart-Computer</span><span class="sxs-lookup"><span data-stu-id="899ad-158">Restart-Computer</span></span>
- <span data-ttu-id="899ad-159">Bilgisayarı durdur</span><span class="sxs-lookup"><span data-stu-id="899ad-159">Stop-Computer</span></span>

### <a name="remove--computername-from--service-cmdlets-5090httpsgithubcompowershellpowershellissues5094"></a><span data-ttu-id="899ad-160">Cmdlet `-ComputerName` 'lerden `*-Service` Kaldır [#5090](https://github.com/PowerShell/PowerShell/issues/5094)</span><span class="sxs-lookup"><span data-stu-id="899ad-160">Remove `-ComputerName` from `*-Service` cmdlets [#5090](https://github.com/PowerShell/PowerShell/issues/5094)</span></span>

<span data-ttu-id="899ad-161">PSRP 'nin tutarlı kullanımını teşvik etmek için, `-ComputerName` parametresi cmdlet 'lerden `*-Service` kaldırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="899ad-161">In order to encourage the consistent use of PSRP, the `-ComputerName` parameter was removed from `*-Service` cmdlets.</span></span>

### <a name="fix-get-item--literalpath-ab-if-ab-doesnt-actually-exist-to-return-error-5197httpsgithubcompowershellpowershellissues5197"></a><span data-ttu-id="899ad-162">Hata `Get-Item -LiteralPath a*b` döndürmek `a*b` için gerçekten yoksa, bu hatayı düzeltir [#5197](https://github.com/PowerShell/PowerShell/issues/5197)</span><span class="sxs-lookup"><span data-stu-id="899ad-162">Fix `Get-Item -LiteralPath a*b` if `a*b` doesn't actually exist to return error [#5197](https://github.com/PowerShell/PowerShell/issues/5197)</span></span>

<span data-ttu-id="899ad-163">Daha önce `-LiteralPath` , bir joker karakter buna benzer şekilde `-Path` davranır ve joker karakter dosya buluyorsa sessizce çıkış olur.</span><span class="sxs-lookup"><span data-stu-id="899ad-163">Previously, `-LiteralPath` given a wildcard would treat it the same as `-Path` and if the wildcard found no files, it would silently exit.</span></span> <span data-ttu-id="899ad-164">Doğru davranış, dosya yoksa `-LiteralPath` hata olması için değişmez değer olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="899ad-164">Correct behavior should be that `-LiteralPath` is literal so if the file doesn't exist, it should error.</span></span> <span data-ttu-id="899ad-165">Değişiklik, kullanılan `-Literal` joker karakterleri değişmez değer olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="899ad-165">Change is to treat wildcards used with `-Literal` as literal.</span></span>

### <a name="import-csv-should-apply-pstypenames-upon-import-when-type-information-is-present-in-the-csv-5134httpsgithubcompowershellpowershellissues5134"></a><span data-ttu-id="899ad-166">`Import-Csv`CSV [#5134](https://github.com/PowerShell/PowerShell/issues/5134) tür bilgisi mevcut olduğunda içeri aktarma sırasındauygulanmalıdır`PSTypeNames`</span><span class="sxs-lookup"><span data-stu-id="899ad-166">`Import-Csv` should apply `PSTypeNames` upon import when type information is present in the CSV [#5134](https://github.com/PowerShell/PowerShell/issues/5134)</span></span>

<span data-ttu-id="899ad-167">Daha önce, ile `Export-CSV` `TypeInformation` `ConvertFrom-Csv` içeri aktarılan ile kullanılarak aktarılan nesneler tür bilgilerini saklamadı.</span><span class="sxs-lookup"><span data-stu-id="899ad-167">Previously, objects exported using `Export-CSV` with `TypeInformation` imported with `ConvertFrom-Csv` were not retaining the type information.</span></span> <span data-ttu-id="899ad-168">Bu değişiklik CSV dosyasından kullanılabiliyorsa, tür `PSTypeNames` bilgilerini üyeye ekler.</span><span class="sxs-lookup"><span data-stu-id="899ad-168">This change adds the type information to `PSTypeNames` member if available from the CSV file.</span></span>

### <a name="-notypeinformation-should-be-default-on-export-csv-5131httpsgithubcompowershellpowershellissues5131"></a><span data-ttu-id="899ad-169">`-NoTypeInformation``Export-Csv` [#5131](https://github.com/PowerShell/PowerShell/issues/5131) varsayılan olmalıdır</span><span class="sxs-lookup"><span data-stu-id="899ad-169">`-NoTypeInformation` should be default on `Export-Csv` [#5131](https://github.com/PowerShell/PowerShell/issues/5131)</span></span>

<span data-ttu-id="899ad-170">Bu değişiklik, tür bilgilerini dahil etmek için varsayılan davranış olan `Export-CSV` müşteri geri bildirimlerine yönelik olarak bildirimde bulunuldu.</span><span class="sxs-lookup"><span data-stu-id="899ad-170">This change was made to address customer feedback on the default behavior of `Export-CSV` to include type information.</span></span>

<span data-ttu-id="899ad-171">Daha önce cmdlet 'i nesnenin tür adını içeren ilk satır olarak bir yorum çıktısı verebilir.</span><span class="sxs-lookup"><span data-stu-id="899ad-171">Previously, the cmdlet would output a comment as the first line containing the type name of the object.</span></span> <span data-ttu-id="899ad-172">Bu değişiklik, çoğu araç tarafından anlaşılmadığından varsayılan olarak bunu göstermez.</span><span class="sxs-lookup"><span data-stu-id="899ad-172">The change is to suppress this by default as it's not understood by most tools.</span></span> <span data-ttu-id="899ad-173">Önceki `-IncludeTypeInformation` davranışı sürdürmek için kullanın.</span><span class="sxs-lookup"><span data-stu-id="899ad-173">Use `-IncludeTypeInformation` to retain the previous behavior.</span></span>

### <a name="web-cmdlets-should-warn-when--credential-is-sent-over-unencrypted-connections-5112httpsgithubcompowershellpowershellissues5112"></a><span data-ttu-id="899ad-174">Şifrelenmemiş bağlantılar üzerinden gönderildiğinde Web `-Credential` cmdlet 'leri uyarmalıdır [#5112](https://github.com/PowerShell/PowerShell/issues/5112)</span><span class="sxs-lookup"><span data-stu-id="899ad-174">Web Cmdlets should warn when `-Credential` is sent over unencrypted connections [#5112](https://github.com/PowerShell/PowerShell/issues/5112)</span></span>

<span data-ttu-id="899ad-175">HTTP kullanırken, parolalar dahil içerik şifresiz metin olarak gönderilir.</span><span class="sxs-lookup"><span data-stu-id="899ad-175">When using HTTP, content including passwords are sent as clear-text.</span></span> <span data-ttu-id="899ad-176">Bu değişiklik, varsayılan olarak buna izin verilmez ve kimlik bilgileri güvenli olmayan bir şekilde geçiriliyorsa bir hata döndürür.</span><span class="sxs-lookup"><span data-stu-id="899ad-176">This change is to not allow this by default and return an error if credentials are being passed in an insecure manner.</span></span> <span data-ttu-id="899ad-177">Kullanıcılar, `-AllowUnencryptedAuthentication` anahtarı kullanarak bunu atlayabilir.</span><span class="sxs-lookup"><span data-stu-id="899ad-177">Users can bypass this by using the `-AllowUnencryptedAuthentication` switch.</span></span>

## <a name="api-changes"></a><span data-ttu-id="899ad-178">API değişiklikleri</span><span class="sxs-lookup"><span data-stu-id="899ad-178">API changes</span></span>

### <a name="remove-addtypecommandbase-class-5407httpsgithubcompowershellpowershellissues5407"></a><span data-ttu-id="899ad-179">Sınıf `AddTypeCommandBase` [#5407](https://github.com/PowerShell/PowerShell/issues/5407) kaldır</span><span class="sxs-lookup"><span data-stu-id="899ad-179">Remove `AddTypeCommandBase` class [#5407](https://github.com/PowerShell/PowerShell/issues/5407)</span></span>

<span data-ttu-id="899ad-180">Sınıfı `AddTypeCommandBase` , performansı artırmak için `Add-Type` sürümünden kaldırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="899ad-180">The `AddTypeCommandBase` class was removed from `Add-Type` to improve performance.</span></span> <span data-ttu-id="899ad-181">Bu sınıf yalnızca Add-Type cmdlet 'i tarafından kullanılır ve kullanıcıları etkilememelidir.</span><span class="sxs-lookup"><span data-stu-id="899ad-181">This class is only used by the Add-Type cmdlet and should not impact users.</span></span>

### <a name="unify-cmdlets-with-parameter--encoding-to-be-of-type-systemtextencoding-5080httpsgithubcompowershellpowershellissues5080"></a><span data-ttu-id="899ad-182">Cmdlet 'i `-Encoding` [#5080](https://github.com/PowerShell/PowerShell/issues/5080) türü `System.Text.Encoding` olacak şekilde bütünleştirme</span><span class="sxs-lookup"><span data-stu-id="899ad-182">Unify cmdlets with parameter `-Encoding` to be of type `System.Text.Encoding` [#5080](https://github.com/PowerShell/PowerShell/issues/5080)</span></span>

<span data-ttu-id="899ad-183">`-Encoding` Değer`Byte` , dosya sistemi sağlayıcısı cmdlet 'lerinden kaldırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="899ad-183">The `-Encoding` value `Byte` has been removed from the filesystem provider cmdlets.</span></span> <span data-ttu-id="899ad-184">Artık yeni bir parametre `-AsByteStream`, bir bayt akışının giriş olarak gerekli olduğunu veya çıktının bir bayt akışı olduğunu belirtmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="899ad-184">A new parameter, `-AsByteStream`, is now used to specify that a byte stream is required as input or that the output is a stream of bytes.</span></span>

### <a name="add-better-error-message-for-empty-and-null--uformat-parameter-5055httpsgithubcompowershellpowershellissues5055"></a><span data-ttu-id="899ad-185">Boş ve null `-UFormat` parametresi için daha iyi hata iletisi ekleyin [#5055](https://github.com/PowerShell/PowerShell/issues/5055)</span><span class="sxs-lookup"><span data-stu-id="899ad-185">Add better error message for empty and null `-UFormat` parameter [#5055](https://github.com/PowerShell/PowerShell/issues/5055)</span></span>

<span data-ttu-id="899ad-186">Daha önce, boş bir biçim dizesi `-UFormat`' a geçirilirken, faydalı olmayan bir hata iletisi görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="899ad-186">Previously, when passing an empty format string to `-UFormat`, an unhelpful error message would appear.</span></span> <span data-ttu-id="899ad-187">Daha açıklayıcı bir hata eklendi.</span><span class="sxs-lookup"><span data-stu-id="899ad-187">A more descriptive error has been added.</span></span>

### <a name="clean-up-console-code-4995httpsgithubcompowershellpowershellissues4995"></a><span data-ttu-id="899ad-188">Konsol kodunu Temizleme [#4995](https://github.com/PowerShell/PowerShell/issues/4995)</span><span class="sxs-lookup"><span data-stu-id="899ad-188">Clean up console code [#4995](https://github.com/PowerShell/PowerShell/issues/4995)</span></span>

<span data-ttu-id="899ad-189">Aşağıdaki özellikler PowerShell Core 'da desteklenmediğinden kaldırılmıştır ve Windows PowerShell için eski nedenlerden dolayı destek eklemek için herhangi bir plan yoktur: `-psconsolefile` anahtar ve kod, `-importsystemmodules` anahtar ve kod ve yazı tipi değiştirme kodu.</span><span class="sxs-lookup"><span data-stu-id="899ad-189">The following features were removed as they are not supported in PowerShell Core, and there are no plans to add support as they exist for legacy reasons for Windows PowerShell: `-psconsolefile` switch and code, `-importsystemmodules` switch and code, and font changing code.</span></span>

### <a name="removed-runspaceconfiguration-support-4942httpsgithubcompowershellpowershellissues4942"></a><span data-ttu-id="899ad-190">Destek `RunspaceConfiguration` [#4942](https://github.com/PowerShell/PowerShell/issues/4942) kaldırıldı</span><span class="sxs-lookup"><span data-stu-id="899ad-190">Removed `RunspaceConfiguration` support [#4942](https://github.com/PowerShell/PowerShell/issues/4942)</span></span>

<span data-ttu-id="899ad-191">Daha önce, API 'yi kullanarak program aracılığıyla bir PowerShell çalışma alanı oluştururken, eski [`RunspaceConfiguration`][runspaceconfig] veya daha yeni bir sürümünü [`InitialSessionState`][iss]kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="899ad-191">Previously, when creating a PowerShell runspace programmatically using the API you could use the legacy [`RunspaceConfiguration`][runspaceconfig] or the newer [`InitialSessionState`][iss].</span></span> <span data-ttu-id="899ad-192">Bu değişiklik `RunspaceConfiguration` , ve yalnızca desteğini destekler `InitialSessionState`.</span><span class="sxs-lookup"><span data-stu-id="899ad-192">This change removed support for `RunspaceConfiguration` and only supports `InitialSessionState`.</span></span>

[runspaceconfig]: https://docs.microsoft.com/dotnet/api/system.management.automation.runspaces.runspaceconfiguration
[iss]: https://docs.microsoft.com/dotnet/api/system.management.automation.runspaces.initialsessionstate

### <a name="commandinvocationintrinsicsinvokescript-bind-arguments-to-input-instead-of-args-4923httpsgithubcompowershellpowershellissues4923"></a><span data-ttu-id="899ad-193">`CommandInvocationIntrinsics.InvokeScript`bağımsız değişkenleri `$input` [](https://github.com/PowerShell/PowerShell/issues/4923) #4923 `$args` yerine bağlama</span><span class="sxs-lookup"><span data-stu-id="899ad-193">`CommandInvocationIntrinsics.InvokeScript` bind arguments to `$input` instead of `$args` [#4923](https://github.com/PowerShell/PowerShell/issues/4923)</span></span>

<span data-ttu-id="899ad-194">Parametrenin yanlış konumu, bağımsız değişkenler yerine giriş olarak geçirilen bağımsız değişkenler ile sonuçlandı.</span><span class="sxs-lookup"><span data-stu-id="899ad-194">An incorrect position of a parameter resulted in the args passed as input instead of as args.</span></span>

### <a name="remove-unsupported--showwindow-switch-from-get-help-4903httpsgithubcompowershellpowershellissues4903"></a><span data-ttu-id="899ad-195">Desteklenmeyen `-showwindow` [anahtarı #4903](https://github.com/PowerShell/PowerShell/issues/4903) Kaldır `Get-Help`</span><span class="sxs-lookup"><span data-stu-id="899ad-195">Remove unsupported `-showwindow` switch from `Get-Help` [#4903](https://github.com/PowerShell/PowerShell/issues/4903)</span></span>

<span data-ttu-id="899ad-196">`-showwindow`CoreCLR 'de desteklenmeyen WPF kullanır.</span><span class="sxs-lookup"><span data-stu-id="899ad-196">`-showwindow` relies on WPF, which is not supported on CoreCLR.</span></span>

### <a name="allow--to-be-used-in-registry-path-for-remove-item-4866httpsgithubcompowershellpowershellissues4866"></a><span data-ttu-id="899ad-197">`Remove-Item` [#4866](https://github.com/PowerShell/PowerShell/issues/4866) için kayıt defteri yolunda \* kullanılmasına izin ver</span><span class="sxs-lookup"><span data-stu-id="899ad-197">Allow \* to be used in registry path for `Remove-Item` [#4866](https://github.com/PowerShell/PowerShell/issues/4866)</span></span>

<span data-ttu-id="899ad-198">Daha önce `-LiteralPath` , bir joker karakter buna benzer şekilde `-Path` davranır ve joker karakter dosya buluyorsa sessizce çıkış olur.</span><span class="sxs-lookup"><span data-stu-id="899ad-198">Previously, `-LiteralPath` given a wildcard would treat it the same as `-Path` and if the wildcard found no files, it would silently exit.</span></span> <span data-ttu-id="899ad-199">Doğru davranış, dosya yoksa `-LiteralPath` hata olması için değişmez değer olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="899ad-199">Correct behavior should be that `-LiteralPath` is literal so if the file doesn't exist, it should error.</span></span> <span data-ttu-id="899ad-200">Değişiklik, kullanılan `-Literal` joker karakterleri değişmez değer olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="899ad-200">Change is to treat wildcards used with `-Literal` as literal.</span></span>

### <a name="fix-set-service-failing-test-4802httpsgithubcompowershellpowershellissues4802"></a><span data-ttu-id="899ad-201">Başarısız `Set-Service` test [#4802](https://github.com/PowerShell/PowerShell/issues/4802) düzeltmesini düzeltir</span><span class="sxs-lookup"><span data-stu-id="899ad-201">Fix `Set-Service` failing test [#4802](https://github.com/PowerShell/PowerShell/issues/4802)</span></span>

<span data-ttu-id="899ad-202">Daha önce kullanıldıysa, `foo` yoksayıldı ve hizmet bir varsayılan başlangıç türüyle oluşturulmuştur. `New-Service -StartupType foo`</span><span class="sxs-lookup"><span data-stu-id="899ad-202">Previously, if `New-Service -StartupType foo` was used, `foo` was ignored and the service was created with some default startup type.</span></span> <span data-ttu-id="899ad-203">Bu değişiklik, geçersiz bir başlangıç türü için açıkça bir hata oluşturmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="899ad-203">This change is to explicitly throw an error for an invalid startup type.</span></span>

### <a name="rename-isosx-to-ismacos-4700httpsgithubcompowershellpowershellissues4700"></a><span data-ttu-id="899ad-204">`$IsOSX` [#4700](https://github.com/PowerShell/PowerShell/issues/4700) olarak `$IsMacOS` yeniden adlandır</span><span class="sxs-lookup"><span data-stu-id="899ad-204">Rename `$IsOSX` to `$IsMacOS` [#4700](https://github.com/PowerShell/PowerShell/issues/4700)</span></span>

<span data-ttu-id="899ad-205">PowerShell 'deki adlandırma, adlandırma ve Apple 'ın OSX yerine macOS kullanımı ile uyumlu olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="899ad-205">The naming in PowerShell should be consistent with our naming and conform to Apple's use of macOS instead of OSX.</span></span> <span data-ttu-id="899ad-206">Bununla birlikte, okunabilirlik ve sürekli olarak Pascal büyük küçük harfe yaklaşıyoruz.</span><span class="sxs-lookup"><span data-stu-id="899ad-206">However, for readability and consistently we are staying with Pascal casing.</span></span>

### <a name="make-error-message-consistent-when-invalid-script-is-passed-to--file-better-error-when-passed-ambiguous-argument-4573httpsgithubcompowershellpowershellissues4573"></a><span data-ttu-id="899ad-207">Geçersiz bağımsız değişken geçirildiğinde daha iyi bir hata olduğunda hata iletisinin tutarlı olmasını sağlayın [#4573](https://github.com/PowerShell/PowerShell/issues/4573)</span><span class="sxs-lookup"><span data-stu-id="899ad-207">Make error message consistent when invalid script is passed to -File, better error when passed ambiguous argument [#4573](https://github.com/PowerShell/PowerShell/issues/4573)</span></span>

<span data-ttu-id="899ad-208">UNIX kurallarıyla hizalamak `pwsh.exe` için çıkış kodlarını değiştirme</span><span class="sxs-lookup"><span data-stu-id="899ad-208">Change the exit codes of `pwsh.exe` to align with Unix conventions</span></span>

### <a name="removal-of-localaccount-and-cmdlets-from--diagnostics-modules-4302httpsgithubcompowershellpowershellissues4302-4303httpsgithubcompowershellpowershellissues4303"></a><span data-ttu-id="899ad-209">Ve cmdlet 'leri modüllerden `Diagnostics`kaldırma. `LocalAccount`</span><span class="sxs-lookup"><span data-stu-id="899ad-209">Removal of `LocalAccount` and cmdlets from  `Diagnostics` modules.</span></span> <span data-ttu-id="899ad-210">[#4302](https://github.com/PowerShell/PowerShell/issues/4302) [#4303](https://github.com/PowerShell/PowerShell/issues/4303)</span><span class="sxs-lookup"><span data-stu-id="899ad-210">[#4302](https://github.com/PowerShell/PowerShell/issues/4302) [#4303](https://github.com/PowerShell/PowerShell/issues/4303)</span></span>

<span data-ttu-id="899ad-211">Desteklenmeyen API 'ler `LocalAccounts` nedeniyle modül `Counter` ve `Diagnostics` modüldeki cmdlet 'ler daha iyi bir çözüm bulunana kadar kaldırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="899ad-211">Due to unsupported APIs, the `LocalAccounts` module and the `Counter` cmdlets in the `Diagnostics` module were removed until a better solution is found.</span></span>

### <a name="executing-powershell-script-with-bool-parameter-does-not-work-4036httpsgithubcompowershellpowershellissues4036"></a><span data-ttu-id="899ad-212">PowerShell betiği bool parametresiyle yürütülemedi [#4036](https://github.com/PowerShell/PowerShell/issues/4036) çalışmıyor</span><span class="sxs-lookup"><span data-stu-id="899ad-212">Executing PowerShell script with bool parameter does not work [#4036](https://github.com/PowerShell/PowerShell/issues/4036)</span></span>

<span data-ttu-id="899ad-213">Daha önce, bir `-File` PowerShell betiğini çalıştırmak için **PowerShell. exe** ' yi (şimdi **pwsh. exe**) kullanarak, parametre değerleri `$true` olarak geçirilecek / `$false` hiçbir yöntem sağlanmaz.</span><span class="sxs-lookup"><span data-stu-id="899ad-213">Previously, using **powershell.exe** (now **pwsh.exe**) to execute a PowerShell script using `-File` provided no way to pass `$true`/`$false` as parameter values.</span></span> <span data-ttu-id="899ad-214">Parametrelereayrıştırılmışdeğerlerolarakdestekeklendi.`$true` / `$false`</span><span class="sxs-lookup"><span data-stu-id="899ad-214">Support for `$true`/`$false` as parsed values to parameters was added.</span></span> <span data-ttu-id="899ad-215">Şu anda belgelenmiş sözdizimi çalışmamakta olduğundan anahtar değerleri de desteklenir.</span><span class="sxs-lookup"><span data-stu-id="899ad-215">Switch values are also supported as currently documented syntax doesn't work.</span></span>

### <a name="remove-clrversion-property-from-psversiontable-4027httpsgithubcompowershellpowershellissues4027"></a><span data-ttu-id="899ad-216">Özelliği #4027 Kaldır `ClrVersion` `$PSVersionTable` [](https://github.com/PowerShell/PowerShell/issues/4027)</span><span class="sxs-lookup"><span data-stu-id="899ad-216">Remove `ClrVersion` property from `$PSVersionTable` [#4027](https://github.com/PowerShell/PowerShell/issues/4027)</span></span>

<span data-ttu-id="899ad-217">`ClrVersion` Özelliği CoreCLRileyararlıdeğildir,sonkullanıcılarbudeğeriuyumluluğu`$PSVersionTable` belirlemede kullanmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="899ad-217">The `ClrVersion` property of `$PSVersionTable` is not useful with CoreCLR, end users should not be using that value to determine compatibility.</span></span>

### <a name="change-positional-parameter-for-powershellexe-from--command-to--file-4019httpsgithubcompowershellpowershellissues4019"></a><span data-ttu-id="899ad-218">`powershell.exe` Konumundan #4019`-Command`konum parametresini [](https://github.com/PowerShell/PowerShell/issues/4019) Değiştir `-File`</span><span class="sxs-lookup"><span data-stu-id="899ad-218">Change positional parameter for `powershell.exe` from `-Command` to `-File` [#4019](https://github.com/PowerShell/PowerShell/issues/4019)</span></span>

<span data-ttu-id="899ad-219">Windows dışı platformlarda PowerShell 'in el ile kullanımını etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="899ad-219">Enable shebang use of PowerShell on non-Windows platforms.</span></span> <span data-ttu-id="899ad-220">Bu, UNIX tabanlı sistemlerde, açıkça `pwsh`çağırmak yerine PowerShell 'i otomatik olarak çağırabilecek bir betik çalıştırılabilir hale getirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="899ad-220">This means on Unix based systems, you can make a script executable that would invoke PowerShell automatically rather than explicitly invoking `pwsh`.</span></span> <span data-ttu-id="899ad-221">Bu, artık ya `powershell foo.ps1` `powershell fooScript` da belirtmeksizin `-File`gibi işlemleri yapabileceğiniz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="899ad-221">This also means that you can now do things like `powershell foo.ps1` or `powershell fooScript` without specifying `-File`.</span></span> <span data-ttu-id="899ad-222">Bununla birlikte, bu değişiklik artık, gibi `-c` `powershell.exe Get-Command`işlemleri açıkça belirtmenizi `-Command` veya ne zaman yapmaya gerek duymanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="899ad-222">However, this change now requires that you explicitly specify `-c` or `-Command` when trying to do things like `powershell.exe Get-Command`.</span></span>

### <a name="implement-unicode-escape-parsing-3958httpsgithubcompowershellpowershellissues3958"></a><span data-ttu-id="899ad-223">Unicode kaçış ayrıştırma [#3958](https://github.com/PowerShell/PowerShell/issues/3958) uygulama</span><span class="sxs-lookup"><span data-stu-id="899ad-223">Implement Unicode escape parsing [#3958](https://github.com/PowerShell/PowerShell/issues/3958)</span></span>

<span data-ttu-id="899ad-224">`` `u####``ya `` `u{####}`` da karşılık gelen Unicode karaktere dönüştürüldü.</span><span class="sxs-lookup"><span data-stu-id="899ad-224">`` `u####`` or `` `u{####}`` is converted to the corresponding Unicode character.</span></span> <span data-ttu-id="899ad-225">Bir sabit değere `` `u``çıkış yapmak için, geri değer: ``` ``u```' i kaçış:.</span><span class="sxs-lookup"><span data-stu-id="899ad-225">To output a literal `` `u``, escape the backtick: ``` ``u```.</span></span>

### <a name="change-new-modulemanifest-encoding-to-utf8nobom-on-non-windows-platforms-3940httpsgithubcompowershellpowershellissues3940"></a><span data-ttu-id="899ad-226">Kodlamayı `New-ModuleManifest` Windows dışı `UTF8NoBOM` platformlarda olarak değiştirin [#3940](https://github.com/PowerShell/PowerShell/issues/3940)</span><span class="sxs-lookup"><span data-stu-id="899ad-226">Change `New-ModuleManifest` encoding to `UTF8NoBOM` on non-Windows platforms [#3940](https://github.com/PowerShell/PowerShell/issues/3940)</span></span>

<span data-ttu-id="899ad-227">Daha önce `New-ModuleManifest` , Linux araçları için bir sorun oluşturarak psd1 bildirimlerini, bom ile UTF-16 içinde oluşturur.</span><span class="sxs-lookup"><span data-stu-id="899ad-227">Previously, `New-ModuleManifest` creates psd1 manifests in UTF-16 with BOM, creating a problem for Linux tools.</span></span> <span data-ttu-id="899ad-228">Bu son değişiklik, ' nin `New-ModuleManifest` kodlamasını Windows olmayan platformlarda UTF (BOM yok) olarak değiştirir.</span><span class="sxs-lookup"><span data-stu-id="899ad-228">This breaking change changes the encoding of `New-ModuleManifest` to be UTF (no BOM) in non-Windows platforms.</span></span>

### <a name="prevent-get-childitem-from-recursing-into-symlinks-1875-3780httpsgithubcompowershellpowershellissues3780"></a><span data-ttu-id="899ad-229">Çözümlemeyin 'e (#1875) yineleme yapılmasını engelleyin `Get-ChildItem` .</span><span class="sxs-lookup"><span data-stu-id="899ad-229">Prevent `Get-ChildItem` from recursing into symlinks (#1875).</span></span> [<span data-ttu-id="899ad-230">#3780</span><span class="sxs-lookup"><span data-stu-id="899ad-230">#3780</span></span>](https://github.com/PowerShell/PowerShell/issues/3780)

<span data-ttu-id="899ad-231">Bu değişiklik, `Get-ChildItem` Unix `ls -r` ve Windows `dir /s` Native komutlarıyla daha fazla bilgi sunar.</span><span class="sxs-lookup"><span data-stu-id="899ad-231">This change brings `Get-ChildItem` more in line with the Unix `ls -r` and the Windows `dir /s` native commands.</span></span> <span data-ttu-id="899ad-232">Belirtilen komutlar gibi cmdlet, özyineleme sırasında bulunan dizinlere yönelik sembolik bağlantıları görüntüler, ancak bunlarla aynı değildir.</span><span class="sxs-lookup"><span data-stu-id="899ad-232">Like the mentioned commands, the cmdlet displays symbolic links to directories found during recursion, but does not recurse into them.</span></span>

### <a name="fix-get-content--delimiter-to-not-include-the-delimiter-in-the-returned-lines-3706httpsgithubcompowershellpowershellissues3706"></a><span data-ttu-id="899ad-233">Döndürülen `Get-Content -Delimiter` satırlarda sınırlayıcıyı dahil etmek için düzeltilir [#3706](https://github.com/PowerShell/PowerShell/issues/3706)</span><span class="sxs-lookup"><span data-stu-id="899ad-233">Fix `Get-Content -Delimiter` to not include the delimiter in the returned lines [#3706](https://github.com/PowerShell/PowerShell/issues/3706)</span></span>

<span data-ttu-id="899ad-234">Daha önce, kullanırken `Get-Content -Delimiter` çıktı, sınırlandırıcının kaldırılması için verilerin daha fazla işlenmesini gerektirdiğinden tutarsızdı ve uygun değildir.</span><span class="sxs-lookup"><span data-stu-id="899ad-234">Previously, the output while using `Get-Content -Delimiter` was inconsistent and inconvenient as it required further processing of the data to remove the delimiter.</span></span> <span data-ttu-id="899ad-235">Bu değişiklik döndürülen satırlardaki sınırlayıcıları kaldırır.</span><span class="sxs-lookup"><span data-stu-id="899ad-235">This change removes the delimiter in returned lines.</span></span>

### <a name="implement-format-hex-in-c-3320httpsgithubcompowershellpowershellissues3320"></a><span data-ttu-id="899ad-236">C# [#3320](https://github.com/PowerShell/PowerShell/issues/3320) biçim-onaltılık uygulama</span><span class="sxs-lookup"><span data-stu-id="899ad-236">Implement Format-Hex in C# [#3320](https://github.com/PowerShell/PowerShell/issues/3320)</span></span>

<span data-ttu-id="899ad-237">`-Raw` Parametresi artık "No-Op" (hiçbir şey yapmaz) olur.</span><span class="sxs-lookup"><span data-stu-id="899ad-237">The `-Raw` parameter is now a "no-op" (in that it does nothing).</span></span> <span data-ttu-id="899ad-238">Tüm çıktının ileri doğru olması, türünün tüm baytlarını içeren sayıların gerçek bir gösterimiyle görüntülenir (Bu değişiklikten önce `-Raw` parametrenin resmi olarak yaptığı şey).</span><span class="sxs-lookup"><span data-stu-id="899ad-238">Going forward all of the output will be displayed with a true representation of numbers that includes all of the bytes for its type (what the `-Raw` parameter was formally doing prior to this change).</span></span>

### <a name="powershell-as-a-default-shell-doesnt-work-with-script-command-3319httpsgithubcompowershellpowershellissues3319"></a><span data-ttu-id="899ad-239">Varsayılan kabuk olarak PowerShell komut dosyası komutuyla çalışmaz [#3319](https://github.com/PowerShell/PowerShell/issues/3319)</span><span class="sxs-lookup"><span data-stu-id="899ad-239">PowerShell as a default shell doesn't work with script command [#3319](https://github.com/PowerShell/PowerShell/issues/3319)</span></span>

<span data-ttu-id="899ad-240">UNIX üzerinde, kabukların etkileşimli bir kabuğu kabul `-i` etmesi ve birçok araç bu davranışı beklediği (`script` Örneğin, PowerShell 'i varsayılan kabuk olarak ayarlarken) ve kabuğu `-i` anahtarla çağıran bir kuraldır.</span><span class="sxs-lookup"><span data-stu-id="899ad-240">On Unix, it is a convention for shells to accept `-i` for an interactive shell and many tools expect this behavior (`script` for example, and when setting PowerShell as the default shell) and calls the shell with the `-i` switch.</span></span> <span data-ttu-id="899ad-241">Bu değişiklik, daha önce de `-i` eşleşmesi `-inputformat`gereken `-in`kısa bir süre olarak kullanılabilecek bir parçadır.</span><span class="sxs-lookup"><span data-stu-id="899ad-241">This change is breaking in that `-i` previously could be used as short hand to match `-inputformat`, which now needs to be `-in`.</span></span>

### <a name="typo-fix-in-get-computerinfo-property-name-3167httpsgithubcompowershellpowershellissues3167"></a><span data-ttu-id="899ad-242">Get-ComputerInfo özellik adında typo onarımı [#3167](https://github.com/PowerShell/PowerShell/issues/3167)</span><span class="sxs-lookup"><span data-stu-id="899ad-242">Typo fix in Get-ComputerInfo property name [#3167](https://github.com/PowerShell/PowerShell/issues/3167)</span></span>

<span data-ttu-id="899ad-243">`BiosSerialNumber`yanlış yazıldı `BiosSeralNumber` ve doğru yazımla değiştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="899ad-243">`BiosSerialNumber` was misspelled as `BiosSeralNumber` and has been changed to the correct spelling.</span></span>

### <a name="add-get-stringhash-and-get-filehash-cmdlets-3024httpsgithubcompowershellpowershellissues3024"></a><span data-ttu-id="899ad-244">Ve `Get-StringHash` cmdlet`Get-FileHash` 'leri ekleme [#3024](https://github.com/PowerShell/PowerShell/issues/3024)</span><span class="sxs-lookup"><span data-stu-id="899ad-244">Add `Get-StringHash` and `Get-FileHash` cmdlets [#3024](https://github.com/PowerShell/PowerShell/issues/3024)</span></span>

<span data-ttu-id="899ad-245">Bu değişiklik, bazı karma algoritmaların CoreFX tarafından desteklenmediği, bu nedenle artık kullanılabilir olmalarıdır:</span><span class="sxs-lookup"><span data-stu-id="899ad-245">This change is that some hash algorithms are not supported by CoreFX, therefore they are no longer available:</span></span>

- `MACTripleDES`
- `RIPEMD160`

### <a name="add-validation-on-get--cmdlets-where-passing-null-returns-all-objects-instead-of-error-2672httpsgithubcompowershellpowershellissues2672"></a><span data-ttu-id="899ad-246">$Null bir hata `Get-*` yerine tüm nesneleri döndüren cmdlet 'lerde doğrulama ekleyin [#2672](https://github.com/PowerShell/PowerShell/issues/2672)</span><span class="sxs-lookup"><span data-stu-id="899ad-246">Add validation on `Get-*` cmdlets where passing $null returns all objects instead of error [#2672](https://github.com/PowerShell/PowerShell/issues/2672)</span></span>

<span data-ttu-id="899ad-247">Aşağıdakilerden `$null` herhangi birine geçirilmesi bir hata oluşturur:</span><span class="sxs-lookup"><span data-stu-id="899ad-247">Passing `$null` to any of the following now throws an error:</span></span>

- `Get-Credential -UserName`
- `Get-Event -SourceIdentifier`
- `Get-EventSubscriber -SourceIdentifier`
- `Get-Help -Name`
- `Get-PSBreakpoint -Script`
- `Get-PSProvider -PSProvider`
- `Get-PSSessionConfiguration -Name`
- `Get-PSSnapin -Name`
- `Get-Runspace -Name`
- `Get-RunspaceDebug -RunspaceName`
- `Get-Service -Name`
- `Get-TraceSource -Name`
- `Get-Variable -Name`
- `Get-WmiObject -Class`
- `Get-WmiObject -Property`

### <a name="add-support-w3c-extended-log-file-format-in-import-csv-2482httpsgithubcompowershellpowershellissues2482"></a><span data-ttu-id="899ad-248">`Import-Csv` [#2482](https://github.com/PowerShell/PowerShell/issues/2482) destek W3C Genişletilmiş günlük dosyası biçimi ekleme</span><span class="sxs-lookup"><span data-stu-id="899ad-248">Add support W3C Extended Log File Format in `Import-Csv` [#2482](https://github.com/PowerShell/PowerShell/issues/2482)</span></span>

<span data-ttu-id="899ad-249">Daha önce `Import-Csv` cmdlet 'i, günlük dosyalarını doğrudan W3C Genişletilmiş günlük biçiminde içeri aktarmak için kullanılamaz ve ek eylem gerekli olacaktır.</span><span class="sxs-lookup"><span data-stu-id="899ad-249">Previously, the `Import-Csv` cmdlet cannot be used to directly import the log files in W3C extended log format and additional action would be required.</span></span> <span data-ttu-id="899ad-250">Bu değişiklik ile W3C Genişletilmiş günlük biçimi desteklenir.</span><span class="sxs-lookup"><span data-stu-id="899ad-250">With this change, W3C extended log format is supported.</span></span>

### <a name="parameter-binding-problem-with-valuefromremainingarguments-in-ps-functions-2035httpsgithubcompowershellpowershellissues2035"></a><span data-ttu-id="899ad-251">PS işlevlerinde parametre bağlama `ValueFromRemainingArguments` sorunu [#2035](https://github.com/PowerShell/PowerShell/issues/2035)</span><span class="sxs-lookup"><span data-stu-id="899ad-251">Parameter binding problem with `ValueFromRemainingArguments` in PS functions [#2035](https://github.com/PowerShell/PowerShell/issues/2035)</span></span>

<span data-ttu-id="899ad-252">`ValueFromRemainingArguments`Şimdi değerleri bir dizi olan tek bir değer yerine dizi olarak döndürür.</span><span class="sxs-lookup"><span data-stu-id="899ad-252">`ValueFromRemainingArguments` now returns the values as an array instead of a single value which itself is an array.</span></span>

### <a name="buildversion-is-removed-from-psversiontable-1415httpsgithubcompowershellpowershellissues1415"></a><span data-ttu-id="899ad-253">`BuildVersion``$PSVersionTable` [#1415](https://github.com/PowerShell/PowerShell/issues/1415) kaldırılır</span><span class="sxs-lookup"><span data-stu-id="899ad-253">`BuildVersion` is removed from `$PSVersionTable` [#1415](https://github.com/PowerShell/PowerShell/issues/1415)</span></span>

<span data-ttu-id="899ad-254">`BuildVersion` Özelliğini öğesinden`$PSVersionTable`kaldırın.</span><span class="sxs-lookup"><span data-stu-id="899ad-254">Remove the `BuildVersion` property from `$PSVersionTable`.</span></span> <span data-ttu-id="899ad-255">Bu özellik Windows Build sürümüne bağlı.</span><span class="sxs-lookup"><span data-stu-id="899ad-255">This property was tied to the Windows build version.</span></span> <span data-ttu-id="899ad-256">Bunun yerine, PowerShell Core 'un derleme `GitCommitId` sürümünü tam olarak almak için kullanmanızı öneririz.</span><span class="sxs-lookup"><span data-stu-id="899ad-256">Instead, we recommend that you use `GitCommitId` to retrieve the exact build version of PowerShell Core.</span></span>

### <a name="changes-to-web-cmdlets"></a><span data-ttu-id="899ad-257">Web cmdlet 'Lerinde yapılan değişiklikler</span><span class="sxs-lookup"><span data-stu-id="899ad-257">Changes to Web Cmdlets</span></span>

<span data-ttu-id="899ad-258">Web cmdlet 'lerinin temel alınan .NET API 'SI olarak `System.Net.Http.HttpClient`değiştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="899ad-258">The underlying .NET API of the Web Cmdlets has been changed to `System.Net.Http.HttpClient`.</span></span> <span data-ttu-id="899ad-259">Bu değişiklik birçok avantaj sağlar.</span><span class="sxs-lookup"><span data-stu-id="899ad-259">This change provides many benefits.</span></span> <span data-ttu-id="899ad-260">Ancak, bu değişiklik, Internet Explorer ile birlikte çalışabilirliğin yanı sıra ve `Invoke-WebRequest` `Invoke-RestMethod`içindeki çeşitli önemli değişikliklere neden oldu.</span><span class="sxs-lookup"><span data-stu-id="899ad-260">However, this change along with a lack of interoperability with Internet Explorer have resulted in several breaking changes within `Invoke-WebRequest` and `Invoke-RestMethod`.</span></span>

- <span data-ttu-id="899ad-261">`Invoke-WebRequest`Artık yalnızca temel HTML ayrıştırmasını desteklemektedir.</span><span class="sxs-lookup"><span data-stu-id="899ad-261">`Invoke-WebRequest` now supports basic HTML Parsing only.</span></span> <span data-ttu-id="899ad-262">`Invoke-WebRequest`her zaman bir `BasicHtmlWebResponseObject` nesne döndürür.</span><span class="sxs-lookup"><span data-stu-id="899ad-262">`Invoke-WebRequest` always returns a `BasicHtmlWebResponseObject` object.</span></span> <span data-ttu-id="899ad-263">`ParsedHtml` Ve`Forms` özellikleri kaldırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="899ad-263">The `ParsedHtml` and `Forms` properties have been removed.</span></span>
- <span data-ttu-id="899ad-264">`BasicHtmlWebResponseObject.Headers`değerler artık `String[]` `String`yerine.</span><span class="sxs-lookup"><span data-stu-id="899ad-264">`BasicHtmlWebResponseObject.Headers` values are now `String[]` instead of `String`.</span></span>
- <span data-ttu-id="899ad-265">`BasicHtmlWebResponseObject.BaseResponse`Artık bir `System.Net.Http.HttpResponseMessage` nesnedir.</span><span class="sxs-lookup"><span data-stu-id="899ad-265">`BasicHtmlWebResponseObject.BaseResponse` is now a `System.Net.Http.HttpResponseMessage` object.</span></span>
- <span data-ttu-id="899ad-266">Web cmdlet özel durumlarının `System.Net.Http.HttpResponseMessage` özelliğiartıkbirnesnedir.`Response`</span><span class="sxs-lookup"><span data-stu-id="899ad-266">The `Response` property on Web Cmdlet exceptions is now a `System.Net.Http.HttpResponseMessage` object.</span></span>
- <span data-ttu-id="899ad-267">Katı RFC üstbilgi ayrıştırma artık `-Headers` ve `-UserAgent` parametresi için varsayılandır.</span><span class="sxs-lookup"><span data-stu-id="899ad-267">Strict RFC header parsing is now default for the `-Headers` and `-UserAgent` parameter.</span></span> <span data-ttu-id="899ad-268">Bu, ile `-SkipHeaderValidation`atlanabilir.</span><span class="sxs-lookup"><span data-stu-id="899ad-268">This can be bypassed with `-SkipHeaderValidation`.</span></span>
- <span data-ttu-id="899ad-269">`file://`ve `ftp://` URI şemaları artık desteklenmiyor.</span><span class="sxs-lookup"><span data-stu-id="899ad-269">`file://` and `ftp://` URI schemes are no longer supported.</span></span>
- <span data-ttu-id="899ad-270">`System.Net.ServicePointManager`ayarlar artık kabul edilemez.</span><span class="sxs-lookup"><span data-stu-id="899ad-270">`System.Net.ServicePointManager` settings are no longer honored.</span></span>
- <span data-ttu-id="899ad-271">Şu anda macOS 'ta sertifika tabanlı kimlik doğrulaması yok.</span><span class="sxs-lookup"><span data-stu-id="899ad-271">There is currently no certificate based authentication available on macOS.</span></span>
- <span data-ttu-id="899ad-272">URI`http://` üzerinden kullanılması hataya neden olur. `-Credential`</span><span class="sxs-lookup"><span data-stu-id="899ad-272">Use of `-Credential` over an `http://` URI will result in an error.</span></span> <span data-ttu-id="899ad-273">Bir `https://` URI kullanın veya hatayı bastırmak `-AllowUnencryptedAuthentication` için parametresini sağlayın.</span><span class="sxs-lookup"><span data-stu-id="899ad-273">Use an `https://` URI or supply the `-AllowUnencryptedAuthentication` parameter to suppress the error.</span></span>
- <span data-ttu-id="899ad-274">`-MaximumRedirection`Şimdi yeniden yönlendirme denemeleri, son yeniden yönlendirmenin sonuçlarını döndürmek yerine, belirtilen limiti aştığında bir sonlandırma hatası veriyor.</span><span class="sxs-lookup"><span data-stu-id="899ad-274">`-MaximumRedirection` now produces a terminating error when redirection attempts exceed the provided limit instead of returning the results of the last redirection.</span></span>
